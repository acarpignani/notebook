[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R for Data Science",
    "section": "",
    "text": "This is the notebook associated with the enhancement class R for Data Science at The Bedford Sixth Form.\nIn this web page you can find all the topics that we have done (or that we are going to do) in the enhancement class, and more. Sometimes, in fact, we might run out of time or focus more on certain aspects, depending on the interests of the students. However here I shall try to keep things simple and as complete as I can. The idea is that whoever misses a lesson, or wants to delve into a specific aspect can either find the answer in this website or find a link pointing to someone much more expert and skilled than me that can answer the question."
  },
  {
    "objectID": "r-basics.html",
    "href": "r-basics.html",
    "title": "Introduction to R",
    "section": "",
    "text": "There are several ways to interact with R. The primary one will be through the command line, also known as console. The command line in RStudio is in the console panel. The name comes from it being the place where one types in commands.\n\n\n\nAn alternative way to interact with R is by typing all the code in an R script. In RStudio, click File &gt; New File &gt; R Script to open a new script. Changing line in the script won’t run the code, however. In order to run the line of code you need to press Ctrl + ENTER in Windows and cmd + ENTER in Mac. There are also commands to run the whole script, but let’s just keep it simple for the time being.\n\n\n\nIn first instance, R is a very powerful and fancy calculator. Typing in the command line numerical expressions with the usual mathematical operations, we get the results we expect:\n\n2 + 3\n\n[1] 5\n\n\nThe four operations in R are +, -, * and / and R follows the usual mathematical rules for the priority of the operations (the one that some people call BIDMAS).\n\n5 * 2 - 12 / 4\n\n[1] 7\n\n\nThe order of the operations can be altered using brackets, like so:\n\n(4 + 5 * 2) / (8 / 2 - 3)\n\n[1] 14\n\n\nBesides the four operations, R has some very useful other operations, such as the integer division %/% and the modulo %% of two numbers. The integer division gives the quotient of the division and the modulo gives the remainder of the division, like so:\n\n25 %/% 4\n\n[1] 6\n\n\n\n25 %% 4\n\n[1] 1\n\n\nIn fact, we have 25 = 6 x 4 + 1.\nWe can also perform powers with R. The syntax is a ^ n to produce a to the power of n. For example,\n\n3 ^ 4\n\n[1] 81\n\n\n\n\nR is also equipped with two special “values” that represent “true” and “false”. These are called the Boolean values and denoted in R by TRUE or T, and FALSE or F. These two special values can be joined together through the logical operations which are: and, or, and not. In R, and is represented by &, or by | and not by !. So, for example, we have:\n\nTRUE & FALSE\n\n[1] FALSE\n\nTRUE | FALSE\n\n[1] TRUE\n\n!FALSE\n\n[1] TRUE\n\n\nAgain, logical values can be linked together with brackets.\n\n\n\n\nOnce started understanding how R works with operations and numbers, we wish to start assigning values to variables and working with variables instead. R provides a special command to assign a value to a variable: &lt;-. This is called the assignment operator. For example\n\nx &lt;- 10\ny &lt;- 2.5\n\nx * y\n\n[1] 25\n\n\nYou don’t have to use a single letter to name a variable. Conversely, it is advisable not to do so, but to use meaningful words that recall the meaning of that variable. For example, to record the height and weight of an individual, we could use\n\nheight &lt;- 150\nweight &lt;- 65\n\n\n\n\n\n\n\nOn the names of variables\n\n\n\nA variable name must start with a letter, but it can contain also numbers, full stop, and underscore after the first letter. There are several different schools of thought about which is the best way to denote variables. In the past, I would have probably chosen a notation such as my.variable to indicate a variable, but after having coded for a long time alongside the magnificent data scientists and software engineers at Posit (former RStudio), I am now more used to a notation like my_variable which I do recommend.\n\n\nWe can work with variables joining them together with the usual operations. For example:\n\nbank_account &lt;- 100\ndeposit &lt;-  30\n\nbank_account &lt;- bank_account + deposit\n\nbank_account\n\n[1] 130\n\n\n\n\n\nUnlike programming languages such as C, Pascal, etc, R doesn’t require to state in advance the type of the variables but it assigns the data type automatically. In most simple cases, the user doesn’t really need bother about the data types, but in some cases, and especially when one starts working with data frames and working in machine learning, awareness of the variable type is very important, and the ability to change data type is paramount.\nR has many different data types. In what follows we shall go through the most important of them.\n\n\nThe most common data type is double, i.e. decimal numbers described using floating point values. Any number is stored in R as a double, unless otherwise specified. So, for example, the following are double.\n\na &lt;- 5\nb &lt;- 2.2\n\nTo see the type of these variable, we can use the command typeof. So\n\ntypeof(a)\n\n[1] \"double\"\n\ntypeof(b)\n\n[1] \"double\"\n\n\n\n\n\nTo tell R that we want the number to be an integer we need to add an L after the number during the assignment. For example\n\nn &lt;- 5L\n\nis an integer. To see this, let’s use again the typeof command:\n\ntypeof(n)\n\n[1] \"integer\"\n\n\nDouble and integer are referred to as numeric variables.\n\n\n\nR has also the possibility to store complex numbers. This is done using the key i for the imaginary unit. For example:\n\nz &lt;- 2 + 3i\nw &lt;- 5 + 2i\n\nIf variables are complex, R knows how to adapt the arithmetic operations to complex numbers. For example,\n\nz + w\n\n[1] 7+5i\n\n2 * z\n\n[1] 4+6i\n\n(1 - 2i) * w\n\n[1] 9-8i\n\n\n\n\n\nAs we have mentioned before, R has two Boolean values (true and false). Their type is logical.\n\np &lt;- TRUE\ntypeof(p)\n\n[1] \"logical\"\n\n\n\n\n\nAnother common type is character, which is the data type of characters and strings. To assign a character type to a variable, we use the quotation marks: both the single ' and the double \" quotation marks work.\n\nchar &lt;- \"Hello, world!\"\ntypeof(char)\n\n[1] \"character\"\n\n\n\n\n\n\n\n\nWarning\n\n\n\nBeside typeof, there is another command that shows the type of a variable: class.\n\n\n\n\n\n\nIn R we can use comparison operators to compare variables and return a logical value. The comparison operators are\n\n\n\nOperator\nName\nSyntax\n\n\n\n\n==\nequal\na == b\n\n\n!=\ndifferent\na != b\n\n\n&lt;=\nsmaller than, or equal to\na &lt;= b\n\n\n&lt;\nsmaller than\na &lt; b\n\n\n&gt;=\ngreater than, or equal to\na &gt;= b\n\n\n&gt;\ngreater than\na &gt; b\n\n\n\nFor example,\n\n5 &gt; 3\n\n[1] TRUE\n\n6 &lt; 3\n\n[1] FALSE\n\n\n\n\n\nBesides google searching and visiting Stack Overflow, there are some build-in functions to get help from R. In fact, most of the R functions have documentation and examples. To access the documentation of a function foo we can either use ?foo or help(foo). For example,\n\nhelp(vector)\n\nopens the documentation with title Vectors - Creation, Coercion, etc.\n\n\n\nR ignores anything after a # sign in a line, whether it is at the beginning of a line or in the middle. Unless the sign # is escaped, this symbol tells R that whatever comes next is a comment, and therefore R ignores it.\nRunning code in the console generally doesn’t require comments, so comments are hardly ever used in this context. However, when a code is saved into an R script, it easily becomes messy and confusing, and that is when comments are become really helpful. Using code we can separate chunks of codes, write little notes on the work that we have done, recall results, and even sometimes copy some results into the script for future reference. It is good practice to always write comments in the code, and I would encourage everyone to always use them in their scripts.",
    "crumbs": [
      "R programming",
      "Introduction to R programming",
      "Introduction to R"
    ]
  },
  {
    "objectID": "r-basics.html#rs-command-line",
    "href": "r-basics.html#rs-command-line",
    "title": "Introduction to R",
    "section": "",
    "text": "There are several ways to interact with R. The primary one will be through the command line, also known as console. The command line in RStudio is in the console panel. The name comes from it being the place where one types in commands.\nIn first instance, R is a very powerful and fancy calculator. Typing in the command line numerical expressions with the usual mathematical operations, we get the results we expect:\n\n2 + 3\n\n[1] 5\n\n\nThe four operations in R are +, -, * and / and R follows the usual mathematical rules for the priority of the operations (the one that some people call BIDMAS).\n\n5 * 2 - 12 / 4\n\n[1] 7\n\n\nThe order of the operations can be altered using brackets, like so:\n\n(4 + 5 * 2) / (8 / 2 - 3)\n\n[1] 14\n\n\nBesides the four operations, R has some very useful other operations, such as the integer division %/% and the modulo %% of two numbers. The integer division gives the quotient of the division and the modulo gives the remainder of the division, like so:\n\n25 %/% 4\n\n[1] 6\n\n\n\n25 %% 4\n\n[1] 1\n\n\nIn fact:\n\n25 = 6 \\times 4 + 1\n\nWe can also perform powers with R. The syntax is a ^ n to produce a^n. For example,\n\n3 ^ 4\n\n[1] 81\n\n\n\n\nR is also equipped with two special “numbers” that represent “TRUE” and “FALSE”. These are TRUE or T and FALSE or F. These two special values can be joined together through the logical operations which are: and, or, and not. In R, and is represented by &, or by | and not by !. So, for example, we have:\n\nTRUE & FALSE\n\n[1] FALSE\n\nTRUE | FALSE\n\n[1] TRUE\n\n!FALSE\n\n[1] TRUE\n\n\nAgain, logical values can be linked together with brackets."
  },
  {
    "objectID": "r-basics.html#r-scripts",
    "href": "r-basics.html#r-scripts",
    "title": "Introduction to R",
    "section": "",
    "text": "Before going ahead and introducing variables, it is convenient to start putting our work into an R Script. In RStudio, click File &gt; New File &gt; R Script to open a new script. Changing line in the script won’t run the code, however. In order to run the line of code you may press Ctrl + ENTER in Windows and cmd + ENTER in Mac. There are also commands to run the whole script, but let’s just keep it simple for the time being.\n\n\nOnce started understanding how R works with operations and numbers, we wish to start assigning values to variables and working with variables instead. R provides a special command to assign a value to a variable: &lt;-. This is called the assignment operator. For example\n\nx &lt;- 10\ny &lt;- 2.5\n\nx * y\n\n[1] 25\n\n\nYou don’t have to use a single letter to name a variable. Conversely, it is advisable not to do so, but to use meaningful words that recall the meaning of that variable. For example, to record the height and weight of an individual, we could use\n\nheight &lt;- 150\nweight &lt;- 65\n\n\n\n\n\n\n\nOn the names of variables\n\n\n\nA variable name must start with a letter, but it can contain also numbers, full stop, and underscore after the first letter. There are several different schools of thought about which is the best way to denote variables. In the past, I would have probably chosen a notation such as my.variable to indicate a variable, but after having coded for a long time alongside the magnificent data scientists and software engineers at Posit (former RStudio), I am now more used to a notation like my_variable which I do recommend.\n\n\nWe can work with variables joining them together with the usual operations. For example:\n\nbank_account &lt;- 100\ndeposit &lt;-  30\n\nbank_account &lt;- bank_account + deposit\n\nbank_account\n\n[1] 130\n\n\n\n\n\nR is a statistical software and in statistics a variable scarcely has only one value, but it is generally given as a list of values (measures). For example, one could have a variable age of the ages of all the employees of a small business. To store this in R, we can use the command c which stands for concatenate. For example\n\nages &lt;- c(25, 33, 45, 37, 28, 23, 42, 58, 29)\n\nNow the variable age is a vector. Let’s find out the length of this vector.\n\nlength(ages)\n\n[1] 9\n\n\nWe may also want to find out the average age of the employees of the business. This can be done with the command mean. E.g.\n\nmean(ages)\n\n[1] 35.55556\n\n\nOther statistical operations are median to calculate the median, IQR to find the interquartile range, sd to find the standard deviation and summary to show a five number summary of the variable, i.e. the minimum, lower quartile, median, upper quartile and maximum in the vector. The function summary also shows the mean.\n\nsummary(ages)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  23.00   28.00   33.00   35.56   42.00   58.00 \n\n\nIt is interesting to immediately notice that R functions may give different outcomes depending on the type of the variable. We shall come back to the type of a variable, but for the moment let’s just say that we consider an employee to be a junior employee if their age is below 33 years. To check whether the ages are below 33 we can use the normal order operations &lt; and &gt;.\n\nis_junior &lt;- ages &lt;= 33\nis_junior\n\n[1]  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE\n\n\nIf we now run the summary command on the variable is_junior we no longer get a five number summary because the variable is_junior is not numeric.\n\nsummary(is_junior)\n\n   Mode   FALSE    TRUE \nlogical       4       5"
  },
  {
    "objectID": "r-basics.html#operations-in-r",
    "href": "r-basics.html#operations-in-r",
    "title": "Introduction to R",
    "section": "",
    "text": "In first instance, R is a very powerful and fancy calculator. Typing in the command line numerical expressions with the usual mathematical operations, we get the results we expect:\n\n2 + 3\n\n[1] 5\n\n\nThe four operations in R are +, -, * and / and R follows the usual mathematical rules for the priority of the operations (the one that some people call BIDMAS).\n\n5 * 2 - 12 / 4\n\n[1] 7\n\n\nThe order of the operations can be altered using brackets, like so:\n\n(4 + 5 * 2) / (8 / 2 - 3)\n\n[1] 14\n\n\nBesides the four operations, R has some very useful other operations, such as the integer division %/% and the modulo %% of two numbers. The integer division gives the quotient of the division and the modulo gives the remainder of the division, like so:\n\n25 %/% 4\n\n[1] 6\n\n\n\n25 %% 4\n\n[1] 1\n\n\nIn fact:\n\n25 = 6 \\times 4 + 1\n\nWe can also perform powers with R. The syntax is a ^ n to produce a^n. For example,\n\n3 ^ 4\n\n[1] 81\n\n\n\n\nR is also equipped with two special “numbers” that represent “TRUE” and “FALSE”. These are TRUE or T and FALSE or F. These two special values can be joined together through the logical operations which are: and, or, and not. In R, and is represented by &, or by | and not by !. So, for example, we have:\n\nTRUE & FALSE\n\n[1] FALSE\n\nTRUE | FALSE\n\n[1] TRUE\n\n!FALSE\n\n[1] TRUE\n\n\nAgain, logical values can be linked together with brackets.\n\n\n\nOnce started understanding how R works with operations and numbers, we wish to start assigning values to variables and working with variables instead. R provides a special command to assign a value to a variable: &lt;-. This is called the assignment operator. For example\n\nx &lt;- 10\ny &lt;- 2.5\n\nx * y\n\n[1] 25\n\n\nYou don’t have to use a single letter to name a variable. Conversely, it is advisable not to do so, but to use meaningful words that recall the meaning of that variable. For example, to record the height and weight of an individual, we could use\n\nheight &lt;- 150\nweight &lt;- 65\n\n\n\n\n\n\n\nOn the names of variables\n\n\n\nA variable name must start with a letter, but it can contain also numbers, full stop, and underscore after the first letter. There are several different schools of thought about which is the best way to denote variables. In the past, I would have probably chosen a notation such as my.variable to indicate a variable, but after having coded for a long time alongside the magnificent data scientists and software engineers at Posit (former RStudio), I am now more used to a notation like my_variable which I do recommend.\n\n\nWe can work with variables joining them together with the usual operations. For example:\n\nbank_account &lt;- 100\ndeposit &lt;-  30\n\nbank_account &lt;- bank_account + deposit\n\nbank_account\n\n[1] 130\n\n\n\n\n\nR is a statistical software and in statistics a variable scarcely has only one value, but it is generally given as a list of values (measures). For example, one could have a variable age of the ages of all the employees of a small business. To store this in R, we can use the command c which stands for concatenate. For example\n\nages &lt;- c(25, 33, 45, 37, 28, 23, 42, 58, 29)\n\nNow the variable age is a vector. Let’s find out the length of this vector.\n\nlength(ages)\n\n[1] 9\n\n\nWe may also want to find out the average age of the employees of the business. This can be done with the command mean. E.g.\n\nmean(ages)\n\n[1] 35.55556\n\n\nOther statistical operations are median to calculate the median, IQR to find the interquartile range, sd to find the standard deviation and summary to show a five number summary of the variable, i.e. the minimum, lower quartile, median, upper quartile and maximum in the vector. The function summary also shows the mean.\n\nsummary(ages)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  23.00   28.00   33.00   35.56   42.00   58.00 \n\n\nIt is interesting to immediately notice that R functions may give different outcomes depending on the type of the variable. We shall come back to the type of a variable, but for the moment let’s just say that we consider an employee to be a junior employee if their age is below 33 years. To check whether the ages are below 33 we can use the normal order operations &lt; and &gt;.\n\nis_junior &lt;- ages &lt;= 33\nis_junior\n\n[1]  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE\n\n\nIf we now run the summary command on the variable is_junior we no longer get a five number summary because the variable is_junior is not numeric.\n\nsummary(is_junior)\n\n   Mode   FALSE    TRUE \nlogical       4       5"
  },
  {
    "objectID": "r-basics.html#arithmetic-with-r",
    "href": "r-basics.html#arithmetic-with-r",
    "title": "Introduction to R",
    "section": "",
    "text": "In first instance, R is a very powerful and fancy calculator. Typing in the command line numerical expressions with the usual mathematical operations, we get the results we expect:\n\n2 + 3\n\n[1] 5\n\n\nThe four operations in R are +, -, * and / and R follows the usual mathematical rules for the priority of the operations (the one that some people call BIDMAS).\n\n5 * 2 - 12 / 4\n\n[1] 7\n\n\nThe order of the operations can be altered using brackets, like so:\n\n(4 + 5 * 2) / (8 / 2 - 3)\n\n[1] 14\n\n\nBesides the four operations, R has some very useful other operations, such as the integer division %/% and the modulo %% of two numbers. The integer division gives the quotient of the division and the modulo gives the remainder of the division, like so:\n\n25 %/% 4\n\n[1] 6\n\n\n\n25 %% 4\n\n[1] 1\n\n\nIn fact, we have 25 = 6 x 4 + 1.\nWe can also perform powers with R. The syntax is a ^ n to produce a to the power of n. For example,\n\n3 ^ 4\n\n[1] 81\n\n\n\n\nR is also equipped with two special “values” that represent “true” and “false”. These are called the Boolean values and denoted in R by TRUE or T, and FALSE or F. These two special values can be joined together through the logical operations which are: and, or, and not. In R, and is represented by &, or by | and not by !. So, for example, we have:\n\nTRUE & FALSE\n\n[1] FALSE\n\nTRUE | FALSE\n\n[1] TRUE\n\n!FALSE\n\n[1] TRUE\n\n\nAgain, logical values can be linked together with brackets.",
    "crumbs": [
      "R programming",
      "Introduction to R programming",
      "Introduction to R"
    ]
  },
  {
    "objectID": "r-basics.html#variables-and-assignment",
    "href": "r-basics.html#variables-and-assignment",
    "title": "Introduction to R",
    "section": "",
    "text": "Once started understanding how R works with operations and numbers, we wish to start assigning values to variables and working with variables instead. R provides a special command to assign a value to a variable: &lt;-. This is called the assignment operator. For example\n\nx &lt;- 10\ny &lt;- 2.5\n\nx * y\n\n[1] 25\n\n\nYou don’t have to use a single letter to name a variable. Conversely, it is advisable not to do so, but to use meaningful words that recall the meaning of that variable. For example, to record the height and weight of an individual, we could use\n\nheight &lt;- 150\nweight &lt;- 65\n\n\n\n\n\n\n\nOn the names of variables\n\n\n\nA variable name must start with a letter, but it can contain also numbers, full stop, and underscore after the first letter. There are several different schools of thought about which is the best way to denote variables. In the past, I would have probably chosen a notation such as my.variable to indicate a variable, but after having coded for a long time alongside the magnificent data scientists and software engineers at Posit (former RStudio), I am now more used to a notation like my_variable which I do recommend.\n\n\nWe can work with variables joining them together with the usual operations. For example:\n\nbank_account &lt;- 100\ndeposit &lt;-  30\n\nbank_account &lt;- bank_account + deposit\n\nbank_account\n\n[1] 130",
    "crumbs": [
      "R programming",
      "Introduction to R programming",
      "Introduction to R"
    ]
  },
  {
    "objectID": "r-basics.html#r-data-types",
    "href": "r-basics.html#r-data-types",
    "title": "Introduction to R",
    "section": "",
    "text": "Unlike programming languages such as C, Pascal, etc, R doesn’t require to state in advance the type of the variables but it assigns the data type automatically. In most simple cases, the user doesn’t really need bother about the data types, but in some cases, and especially when one starts working with data frames and working in machine learning, awareness of the variable type is very important, and the ability to change data type is paramount.\nR has many different data types. In what follows we shall go through the most important of them.\n\n\nThe most common data type is double, i.e. decimal numbers described using floating point values. Any number is stored in R as a double, unless otherwise specified. So, for example, the following are double.\n\na &lt;- 5\nb &lt;- 2.2\n\nTo see the type of these variable, we can use the command typeof. So\n\ntypeof(a)\n\n[1] \"double\"\n\ntypeof(b)\n\n[1] \"double\"\n\n\n\n\n\nTo tell R that we want the number to be an integer we need to add an L after the number during the assignment. For example\n\nn &lt;- 5L\n\nis an integer. To see this, let’s use again the typeof command:\n\ntypeof(n)\n\n[1] \"integer\"\n\n\nDouble and integer are referred to as numeric variables.\n\n\n\nR has also the possibility to store complex numbers. This is done using the key i for the imaginary unit. For example:\n\nz &lt;- 2 + 3i\nw &lt;- 5 + 2i\n\nIf variables are complex, R knows how to adapt the arithmetic operations to complex numbers. For example,\n\nz + w\n\n[1] 7+5i\n\n2 * z\n\n[1] 4+6i\n\n(1 - 2i) * w\n\n[1] 9-8i\n\n\n\n\n\nAs we have mentioned before, R has two Boolean values (true and false). Their type is logical.\n\np &lt;- TRUE\ntypeof(p)\n\n[1] \"logical\"\n\n\n\n\n\nAnother common type is character, which is the data type of characters and strings. To assign a character type to a variable, we use the quotation marks: both the single ' and the double \" quotation marks work.\n\nchar &lt;- \"Hello, world!\"\ntypeof(char)\n\n[1] \"character\"\n\n\n\n\n\n\n\n\nWarning\n\n\n\nBeside typeof, there is another command that shows the type of a variable: class.",
    "crumbs": [
      "R programming",
      "Introduction to R programming",
      "Introduction to R"
    ]
  },
  {
    "objectID": "r-basics.html#comparison-operators",
    "href": "r-basics.html#comparison-operators",
    "title": "Introduction to R",
    "section": "",
    "text": "In R we can use comparison operators to compare variables and return a logical value. The comparison operators are\n\n\n\nOperator\nName\nSyntax\n\n\n\n\n==\nequal\na == b\n\n\n!=\ndifferent\na != b\n\n\n&lt;=\nsmaller than, or equal to\na &lt;= b\n\n\n&lt;\nsmaller than\na &lt; b\n\n\n&gt;=\ngreater than, or equal to\na &gt;= b\n\n\n&gt;\ngreater than\na &gt; b\n\n\n\nFor example,\n\n5 &gt; 3\n\n[1] TRUE\n\n6 &lt; 3\n\n[1] FALSE",
    "crumbs": [
      "R programming",
      "Introduction to R programming",
      "Introduction to R"
    ]
  },
  {
    "objectID": "vectors.html",
    "href": "vectors.html",
    "title": "Vectors",
    "section": "",
    "text": "R is a statistical software and in statistics a variable scarcely has only one value, but it is generally given as a list of values (measurements). For example, one could have a variable ages of the ages of all the employees of a small business. To store this in R, we can use the function c() which stands for concatenate. To use this function, we pass the values of the vector as a list, separated by a comma. For example\n\nages &lt;- c(25, 33, 45, 37, 28, 23, 42, 58, 29)\nages\n\n[1] 25 33 45 37 28 23 42 58 29\n\n\nNow the variable ages is a vector. Let’s find out the length of this vector.\n\nlength(ages)\n\n[1] 9\n\n\n\n\nWe can create vectors with any data type. For example,\n\nnvec &lt;- c(1, 2, 3, 4, 5)\ntypeof(nvec)\n\n[1] \"double\"\n\ncvec &lt;- c(\"G\", \"C\", \"S\", \"E\")\ntypeof(cvec)\n\n[1] \"character\"\n\nlvec &lt;- c(TRUE, FALSE)\ntypeof(lvec)\n\n[1] \"logical\"\n\n\nIt is important to note now that all the elements of a vector must all have the same type. In fact, if we attempt to mix data types in a vector, R will convert them to force them to have all the same data type. For example,\n\nv &lt;- c(FALSE, 3, TRUE, 6)\ntypeof(v)\n\n[1] \"double\"\n\n\nIn fact, R will convert TRUE as 1 and FALSE as 0.\n\nw &lt;- c(\"A\", 1)\ntypeof(w)\n\n[1] \"character\"\n\n\nIn this case, as we could imagine, R converts everything to be a character.\n\nw\n\n[1] \"A\" \"1\"\n\n\n\n\n\nAn interesting feature of R is that each element in a vector can be named. Precisely, we can use the function name() to assign to each element of a vector a name. For example, imagine the following vector contains a week of temperatures:\n\ntemp &lt;- c(18, 16, 17, 17, 18, 16, 15)\ntemp\n\n[1] 18 16 17 17 18 16 15\n\n\nWe know that we have 7 temperatures for the 7 days of the week, but which temperature corresponds to which day? Does it start from Monday or from Sunday, or another day of the week? This is where the function name() can be used to assign a label to each value of the vector temp, as follows:\n\ndays &lt;- c(\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\")\nnames(temp) &lt;- days\ntemp\n\nMon Tue Wed Thu Fri Sat Sun \n 18  16  17  17  18  16  15 \n\n\n\n\n\n\nAs we have mentioned a couple of times already, R is a statistical software. This means that all aspects of R are centred on working with statistical data. Therefore, performing operations in R is specifically designed to make working with data as simple as possible. In particular, all arithmetic operations are vectorised, which means that the operations occur on an element by element basis. for example, take the following two vectors:\n\nvec_1 &lt;- c(1, 2, 3)\nvec_2 &lt;- c(5, 6, 7)\n\nAdding vectors:\n\nvec_1 + vec_2\n\n[1]  6  8 10\n\n\nSubtracting vectors:\n\nvec_1 - vec_2\n\n[1] -4 -4 -4\n\n\nMultiplying vectors:\n\nvec_1 * vec_2\n\n[1]  5 12 21\n\n\nDividing vectors:\n\nvec_1 / vec_2\n\n[1] 0.2000000 0.3333333 0.4285714\n\n\n\n\nWe can apply comparison operations of a single number to an entire vector. R will apply the comparison to every element of the vector, like so:\n\nvec &lt;- c(1, 2, 3, 4, 5, 6)\nvec &lt; 3.5\n\n[1]  TRUE  TRUE  TRUE FALSE FALSE FALSE\n\nvec == 2\n\n[1] FALSE  TRUE FALSE FALSE FALSE FALSE\n\n\n\n\n\nLet’s come back to the example of the age of the employees of a business, ages. Imagine we wish to find the mean of the ages. To do so, we can use the function mean(), like so:\nmean(ages)\nSimilarly, we could find the median, the standard deviation, the interquartile range (IQR), etc, with similar functions. The following table contains some of the most common mathematical functions in R. A more comprehensive list of functions can be find in the R Reference Card published on CRAN.\n\n\n\n\n\n\n\nFunction\nMeaning\n\n\n\n\nsum(x)\nsum of the elements of x\n\n\nmin(x)\nminimum of the elements of x\n\n\nmax(x)\nmaximum of the elements of x\n\n\nmean(x)\nmean of the elements of x\n\n\nmedian(x)\nmedian of the elements of x\n\n\nquantile(x, probs)\nsample quantiles corresponding to the given probabilities (defaults to 0, 0.25, 0.5, 0.75, 1)\n\n\nvar(x)\nvariance of the elements of x (calculated on n-1)\n\n\nsd(x)\nstandard deviation of x (square root of the variance)\n\n\nIQR(x)\ninterquartile range of x\n\n\nlog(x, base)\ncomputes the logarithm of x with base base (default e, the natural logarithm)\n\n\n\nAnother very nice function is summary() which returns a summary statistics of the vector, i.e. the minimum, lower quartile, median, mean, upper quartile and maximum of the vector. For example,\n\nsummary(ages)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  23.00   28.00   33.00   35.56   42.00   58.00 \n\n\nIt is interesting to notice that R functions may give different outcomes depending on the type of the variable. We shall come back to the type of a variable, but for the moment let’s just say that we consider an employee to be a junior employee if their age is below 33 years. To check whether the ages are below 33 we can use the comparison operators, like so:\n\nis_junior &lt;- ages &lt;= 33\nis_junior\n\n[1]  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE\n\n\nIf we now run the summary command on the variable is_junior we no longer get a five number summary because the variable is_junior is not numeric.\n\nsummary(is_junior)\n\n   Mode   FALSE    TRUE \nlogical       4       5 \n\n\n\n\n\n\nIt is sometimes important to be able to access a particular element of a given vector. For example, consider the following vector:\n\nvec &lt;- c(5, 10, 15, 20, 25, 30, 35, 40)\n\nWe can use the square brackets [ ] to access the individual elements of the vector. This can be done by indexing. In its simplest form, indexing works by using the brackets to pass the index position corresponding to the element as a number. Keep in mind that, unlike python, in R the index position starts at 1. So, for example,\n\nvec[3]\n\n[1] 15\n\n\nSometimes, however, we wish to access multiple elements at the same time. This can be done passing a vector of indices inside the square brackets; like so:\n\nvec[c(2, 3, 5)]\n\n[1] 10 15 25\n\n\nIf we pass a negative index to the vector, R will instead return the vector with all but the index passed. For example,\n\nvec[-3]\n\n[1]  5 10 20 25 30 35 40\n\n\n\n\nWe can also use the colon (:) to indicate a slice of vector. The colon operator from:to creates a vector of numbers that starts from from and ends at to, increasing by 1 unit every time. So, for example,\n\n3:7\n\n[1] 3 4 5 6 7\n\n\nNotice that if decimal numbers are given, it is possible that the second number is not necessarily part of the list, because the sequence terminates with the bigger number smaller than to, like so:\n\n3.5:7.2\n\n[1] 3.5 4.5 5.5 6.5\n\n\nSo, using the colon, we can get a slice of a vector, using the following syntax:\nvector[start_index:stop_index]\nFor example,\n\nvec[2:4]\n\n[1] 10 15 20\n\n\nNotice how the elements both at the starting and stopping index are included.\n\n\n\nWe have previously seen that we can assign names to the elements of a vector. For example,\n\nvec &lt;- c(5, 10, 15, 20, 25)\nnames(vec) &lt;- c(\"a\", \"b\", \"c\", \"d\", \"e\")\nvec\n\n a  b  c  d  e \n 5 10 15 20 25 \n\n\nWe can then use the name along with the indexing brackets to grab the individual elements from the vector.\n\nvec[\"c\"]\n\n c \n15 \n\n\nAgain, we can also pass a vector of names to grab more than one vector at the same time.\n\nvec[c(\"a\", \"c\", \"e\")]\n\n a  c  e \n 5 15 25 \n\n\n\n\n\nAs we have mentioned before, talking about the comparison operators with vectors, we can use comparison operators to filter out elements from a vector. Sometimes this is referred to as boolean/logical masking, because we are creating a vector of logicals to filter out results you want.\nLet’s see an example of this. Take the vector\n\nvec &lt;- 1:10\nvec\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nWe can pass to the brackets a logical statement.\n\nvec[vec &gt; 6]\n\n[1]  7  8  9 10\n\n\nLet’s break this down to see how it works. First, let’s have a look at the vector\n\nvec &gt; 6\n\n [1] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\n\n\nAs we can see, it returns a logical vector with the same length as vec whose elements says whether it is true or false that the element in that position is greater than 6. When we pass a logical vector, such as this, to another vector through the brackets, R will return only the elements of the vector corresponding to a true value in the logical vector.\nTo make this more clear, we could even assign a name to this logical vector and pass the name to the vector, like so:\n\nfilter &lt;- vec &gt; 6\nfilter\n\n [1] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\n\nvec[filter]\n\n[1]  7  8  9 10\n\n\n\n\n\n\nBesides the function c() we have already seen that the colon operator from:to generates a sequence starting at from and ending at to. Another function that does the same job is seq(from, to, by = ). The parameter by specifies the increment of the sequence and its default value is 1. So, for example,\n\nseq(5, 16, by = 2)\n\n[1]  5  7  9 11 13 15\n\n\nAnother function that creates a vector is rep(x, times) which repeats the vector x times times.\n\nrep(c(1, 2), times = 3)\n\n[1] 1 2 1 2 1 2\n\n\nThe function rep has an alternative parameter each which repeats ‘each’ element of x each times. For example,\n\nrep(c(1, 2), each = 3)\n\n[1] 1 1 1 2 2 2\n\n\n\n\n\nSometimes instead of generating data with a pattern, we would like to simulate data. R is perfect for this job, as it has a very good implementation of all the most common and important statistical distributions needed. However, before we can simulate data, it is vital to say a few words about random data generation and reproducibility.\n\n\nAccording to Wikipedia, random number generation is a process by which, often by means of a random number generator (RGN), a sequence of numbers or symbols that cannot be reasonably predicted better than by random chance is generated. True random number generators are generally hardware based (for example by rolling a die). Software typically use a pseudo-random number generator (PRNG) which is an algorithm that generates a sequence of numbers that only looks random but that is in fact pre-determined. On Wikipedia there is long list of PRNGs, but for our scope, suffices it to say that the numbers that can be generated by R are in actual facts not random, but they would pass a random test, which means that they would look random from a mathematical point of view. If you want to know more about how R generates random numbers, you may wish to type help(\"RNG\") on your console.\n\n\n\nThis may look like a disadvantage, but it is actually a very important aspect of simulation. By means of the fact that random numbers are not-random after all, this means that if we “set a seed” we can then reproduce the exact random sequence again. This means that different user can perform the same simulation, obtaining the same result, as long as they use the same PRNG and they set the same seed.\nIn R the command to set the PRNG seed is set.seed().\nThis function needs to be assigned a number, the seed, which starts the sequence.\n\n\n\nLet’s see an example. Imagine we wish to roll a die. This means that we have a set of six possible outcomes (coded as 1 to 6), and by rolling a fair die we select one of them and all of them have the same probability (1 out of 6) to be selected. This can be done easily by sampling the set 1 to 6, i.e.\n\nset.seed(123)\nsample(1:6, 1)\n\n[1] 3\n\n\nImagine now we want to roll our die 10 times. This can be simulated using a similar code: we need to sample 10 times the set 1 to 6, but this sample must be with replacement. Thus we need to add the parameter replace = TRUE to the code to ensure that R samples with replacement. Let’s also set the same seed.\n\nset.seed(123)\nsample(1:6, 10, replace = TRUE)\n\n [1] 3 6 3 2 2 6 3 5 4 6\n\n\nWe may notice that having set the same seed, the first number is exactly the same as before.\n\n\n\n\n\n\nCaution\n\n\n\nA note of caution here: it is a good practice to set the seed every time we use a random generator function. In fact, once the seed has been set, the random function will use the PRGN in a specific way and different versions of the same function might use the PRNG in different ways. So once we access the PRNG again, it is good to always maintain control by choosing the seed, to ensure reproducibility.\n\n\n\n\n\nSuppose now we want to simulate a measurement (e.g. the temperature of a town). In this case we can’t sample from a population, but we need to use a statistical distribution. The statistical distribution that models a measurement is called the normal distribution and it has two parameters: the mean and the standard deviation. The mean represents the typical value of this measurement, and the standard deviation represent an approximation of the error made in taking this measurement.\nSo let’s run a simulation of 10 measurements of an average temperature of 18 degrees with a variability of 3 degrees.\n\nset.seed(101)\nrnorm(10, mean = 18, sd = 3)\n\n [1] 17.02189 19.65739 15.97517 18.64308 18.93231 21.52190 19.85637 17.66180\n [9] 20.75108 17.33022\n\n\nThis is way too accurate: let’s just round this to integers.\n\nset.seed(101)\nround(rnorm(10, mean = 18, sd = 3))\n\n [1] 17 20 16 19 19 22 20 18 21 17\n\n\nAnother very common distribution is the so called uniform distribution which gives the same probability to all numbers between a minimum and a maximum chosen numbers (defaults are min = 0 and max = 1). Let’s simulate 100 values from a uniform distribution:\n\nset.seed(111)\nrunif(100)\n\n  [1] 0.5929812845 0.7264811215 0.3704220036 0.5149238301 0.3776632159\n  [6] 0.4183373258 0.0106578451 0.5322952422 0.4321606164 0.0936815199\n [11] 0.5557799137 0.5902284889 0.0671411434 0.0475478533 0.1562025158\n [16] 0.4464277634 0.1714436871 0.9665342933 0.3106664298 0.6144663957\n [21] 0.4310607871 0.2855270915 0.3421513471 0.3866276275 0.9675274789\n [26] 0.3220267275 0.6532294548 0.2833034997 0.7874279192 0.5959206352\n [31] 0.0585964625 0.5098998600 0.4657924296 0.4693590938 0.3597453721\n [36] 0.7134103531 0.1163154817 0.7839926207 0.6421407105 0.8051009134\n [41] 0.6411978584 0.3284916454 0.6356909545 0.9285191579 0.5752422044\n [46] 0.3666838536 0.4366072204 0.8559219379 0.6279955737 0.7937756432\n [51] 0.7251648332 0.5850447209 0.0327716474 0.3329946804 0.9967166614\n [56] 0.5482733699 0.5758329388 0.4563152066 0.0965785654 0.8055401752\n [61] 0.0009253006 0.4667440471 0.1732608730 0.2592225648 0.9192820815\n [66] 0.2319295844 0.0525656715 0.3043926249 0.0117258150 0.3007076983\n [71] 0.8775839461 0.6652787277 0.4537648347 0.0533223320 0.6309068091\n [76] 0.4421851884 0.2673464869 0.9837744189 0.0951241532 0.7859691235\n [81] 0.1198521818 0.8812154671 0.1310980669 0.4003378763 0.0866140136\n [86] 0.3747997992 0.6847860171 0.7347726757 0.7709477365 0.5799853499\n [91] 0.5110989846 0.8529837073 0.6298211562 0.5790059080 0.7402492894\n [96] 0.3871497631 0.9935344572 0.3980894811 0.9750010339 0.8244822009\n\n\nThe table below shows the most common distributions with their syntax and a brief explanation.\n\n\n\n\n\n\n\n\nName\nSynatx\nExample of usage\n\n\n\n\nNormal distribution\nrnorm(n, mean = 0, sd = 1)\nThe normal distribution models measurements with mean mean and error sd\n\n\nUniform distribution\nrunif(n, min = 0, max = 1)\nThe uniform distribution is generally used to generate a sequence of random numbers\n\n\nBinomial distribution\nrbinom(n, size, prob)\nThe binomial distribution models the number of successes in size trials with probability of success prob\n\n\nPoisson distribution\nrpois(n, lambda)\nThe Poisson distribution is also called the “count” distribution: it models the number of events occurring at a constant rate in a given time frame. lambda is the mean number of events occurring.\n\n\nExponential distribution\nrexp(n, rate = 1)\nThe exponential distribution models the time to wait until the next event occurs, such as a failure or a success. rate is the average rate at which the events occur.\n\n\nGeometric distribution\nrgeom(n, prob)\nThe geometric distribution models the instant of first success in a sequence of trials with probability of success prob",
    "crumbs": [
      "R programming",
      "Introduction to R programming",
      "Vectors"
    ]
  },
  {
    "objectID": "vectors.html#vector-basics",
    "href": "vectors.html#vector-basics",
    "title": "Vectors",
    "section": "",
    "text": "R is a statistical software and in statistics a variable scarcely has only one value, but it is generally given as a list of values (measurements). For example, one could have a variable ages of the ages of all the employees of a small business. To store this in R, we can use the function c() which stands for concatenate. To use this function, we pass the values of the vector as a list, separated by a comma. For example\n\nages &lt;- c(25, 33, 45, 37, 28, 23, 42, 58, 29)\nages\n\n[1] 25 33 45 37 28 23 42 58 29\n\n\nNow the variable ages is a vector. Let’s find out the length of this vector.\n\nlength(ages)\n\n[1] 9\n\n\n\n\nWe can create vectors with any data type. For example,\n\nnvec &lt;- c(1, 2, 3, 4, 5)\ntypeof(nvec)\n\n[1] \"double\"\n\ncvec &lt;- c(\"G\", \"C\", \"S\", \"E\")\ntypeof(cvec)\n\n[1] \"character\"\n\nlvec &lt;- c(TRUE, FALSE)\ntypeof(lvec)\n\n[1] \"logical\"\n\n\nIt is important to note now that all the elements of a vector must all have the same type. In fact, if we attempt to mix data types in a vector, R will convert them to force them to have all the same data type. For example,\n\nv &lt;- c(FALSE, 3, TRUE, 6)\ntypeof(v)\n\n[1] \"double\"\n\n\nIn fact, R will convert TRUE as 1 and FALSE as 0.\n\nw &lt;- c(\"A\", 1)\ntypeof(w)\n\n[1] \"character\"\n\n\nIn this case, as we could imagine, R converts everything to be a character.\n\nw\n\n[1] \"A\" \"1\"\n\n\n\n\n\nAn interesting feature of R is that each element in a vector can be named. Precisely, we can use the function name() to assign to each element of a vector a name. For example, imagine the following vector contains a week of temperatures:\n\ntemp &lt;- c(18, 16, 17, 17, 18, 16, 15)\ntemp\n\n[1] 18 16 17 17 18 16 15\n\n\nWe know that we have 7 temperatures for the 7 days of the week, but which temperature corresponds to which day? Does it start from Monday or from Sunday, or another day of the week? This is where the function name() can be used to assign a label to each value of the vector temp, as follows:\n\ndays &lt;- c(\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\")\nnames(temp) &lt;- days\ntemp\n\nMon Tue Wed Thu Fri Sat Sun \n 18  16  17  17  18  16  15",
    "crumbs": [
      "R programming",
      "Introduction to R programming",
      "Vectors"
    ]
  },
  {
    "objectID": "vectors.html#operations-with-vectors",
    "href": "vectors.html#operations-with-vectors",
    "title": "Vectors",
    "section": "",
    "text": "As we have mentioned a couple of times already, R is a statistical software. This means that all aspects of R are centred on working with statistical data. Therefore, performing operations in R is specifically designed to make working with data as simple as possible. In particular, all arithmetic operations are vectorised, which means that the operations occur on an element by element basis. for example, take the following two vectors:\n\nvec_1 &lt;- c(1, 2, 3)\nvec_2 &lt;- c(5, 6, 7)\n\nAdding vectors:\n\nvec_1 + vec_2\n\n[1]  6  8 10\n\n\nSubtracting vectors:\n\nvec_1 - vec_2\n\n[1] -4 -4 -4\n\n\nMultiplying vectors:\n\nvec_1 * vec_2\n\n[1]  5 12 21\n\n\nDividing vectors:\n\nvec_1 / vec_2\n\n[1] 0.2000000 0.3333333 0.4285714\n\n\n\n\nWe can apply comparison operations of a single number to an entire vector. R will apply the comparison to every element of the vector, like so:\n\nvec &lt;- c(1, 2, 3, 4, 5, 6)\nvec &lt; 3.5\n\n[1]  TRUE  TRUE  TRUE FALSE FALSE FALSE\n\nvec == 2\n\n[1] FALSE  TRUE FALSE FALSE FALSE FALSE\n\n\n\n\n\nLet’s come back to the example of the age of the employees of a business, ages. Imagine we wish to find the mean of the ages. To do so, we can use the function mean(), like so:\nmean(ages)\nSimilarly, we could find the median, the standard deviation, the interquartile range (IQR), etc, with similar functions. The following table contains some of the most common mathematical functions in R. A more comprehensive list of functions can be find in the R Reference Card published on CRAN.\n\n\n\n\n\n\n\nFunction\nMeaning\n\n\n\n\nsum(x)\nsum of the elements of x\n\n\nmin(x)\nminimum of the elements of x\n\n\nmax(x)\nmaximum of the elements of x\n\n\nmean(x)\nmean of the elements of x\n\n\nmedian(x)\nmedian of the elements of x\n\n\nquantile(x, probs)\nsample quantiles corresponding to the given probabilities (defaults to 0, 0.25, 0.5, 0.75, 1)\n\n\nvar(x)\nvariance of the elements of x (calculated on n-1)\n\n\nsd(x)\nstandard deviation of x (square root of the variance)\n\n\nIQR(x)\ninterquartile range of x\n\n\nlog(x, base)\ncomputes the logarithm of x with base base (default e, the natural logarithm)\n\n\n\nAnother very nice function is summary() which returns a summary statistics of the vector, i.e. the minimum, lower quartile, median, mean, upper quartile and maximum of the vector. For example,\n\nsummary(ages)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  23.00   28.00   33.00   35.56   42.00   58.00 \n\n\nIt is interesting to notice that R functions may give different outcomes depending on the type of the variable. We shall come back to the type of a variable, but for the moment let’s just say that we consider an employee to be a junior employee if their age is below 33 years. To check whether the ages are below 33 we can use the comparison operators, like so:\n\nis_junior &lt;- ages &lt;= 33\nis_junior\n\n[1]  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE\n\n\nIf we now run the summary command on the variable is_junior we no longer get a five number summary because the variable is_junior is not numeric.\n\nsummary(is_junior)\n\n   Mode   FALSE    TRUE \nlogical       4       5",
    "crumbs": [
      "R programming",
      "Introduction to R programming",
      "Vectors"
    ]
  },
  {
    "objectID": "r-basics.html#getting-help-with-r",
    "href": "r-basics.html#getting-help-with-r",
    "title": "Introduction to R",
    "section": "",
    "text": "Besides google searching and visiting Stack Overflow, there are some build-in functions to get help from R. In fact, most of the R functions have documentation and examples. To access the documentation of a function foo we can either use ?foo or help(foo). For example,\n\nhelp(vector)\n\nopens the documentation with title Vectors - Creation, Coercion, etc.",
    "crumbs": [
      "R programming",
      "Introduction to R programming",
      "Introduction to R"
    ]
  },
  {
    "objectID": "vectors.html#vector-indexing-and-slicing",
    "href": "vectors.html#vector-indexing-and-slicing",
    "title": "Vectors",
    "section": "",
    "text": "It is sometimes important to be able to access a particular element of a given vector. For example, consider the following vector:\n\nvec &lt;- c(5, 10, 15, 20, 25, 30, 35, 40)\n\nWe can use the square brackets [ ] to access the individual elements of the vector. This can be done by indexing. In its simplest form, indexing works by using the brackets to pass the index position corresponding to the element as a number. Keep in mind that, unlike python, in R the index position starts at 1. So, for example,\n\nvec[3]\n\n[1] 15\n\n\nSometimes, however, we wish to access multiple elements at the same time. This can be done passing a vector of indices inside the square brackets; like so:\n\nvec[c(2, 3, 5)]\n\n[1] 10 15 25\n\n\nIf we pass a negative index to the vector, R will instead return the vector with all but the index passed. For example,\n\nvec[-3]\n\n[1]  5 10 20 25 30 35 40\n\n\n\n\nWe can also use the colon (:) to indicate a slice of vector. The colon operator from:to creates a vector of numbers that starts from from and ends at to, increasing by 1 unit every time. So, for example,\n\n3:7\n\n[1] 3 4 5 6 7\n\n\nNotice that if decimal numbers are given, it is possible that the second number is not necessarily part of the list, because the sequence terminates with the bigger number smaller than to, like so:\n\n3.5:7.2\n\n[1] 3.5 4.5 5.5 6.5\n\n\nSo, using the colon, we can get a slice of a vector, using the following syntax:\nvector[start_index:stop_index]\nFor example,\n\nvec[2:4]\n\n[1] 10 15 20\n\n\nNotice how the elements both at the starting and stopping index are included.\n\n\n\nWe have previously seen that we can assign names to the elements of a vector. For example,\n\nvec &lt;- c(5, 10, 15, 20, 25)\nnames(vec) &lt;- c(\"a\", \"b\", \"c\", \"d\", \"e\")\nvec\n\n a  b  c  d  e \n 5 10 15 20 25 \n\n\nWe can then use the name along with the indexing brackets to grab the individual elements from the vector.\n\nvec[\"c\"]\n\n c \n15 \n\n\nAgain, we can also pass a vector of names to grab more than one vector at the same time.\n\nvec[c(\"a\", \"c\", \"e\")]\n\n a  c  e \n 5 15 25 \n\n\n\n\n\nAs we have mentioned before, talking about the comparison operators with vectors, we can use comparison operators to filter out elements from a vector. Sometimes this is referred to as boolean/logical masking, because we are creating a vector of logicals to filter out results you want.\nLet’s see an example of this. Take the vector\n\nvec &lt;- 1:10\nvec\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nWe can pass to the brackets a logical statement.\n\nvec[vec &gt; 6]\n\n[1]  7  8  9 10\n\n\nLet’s break this down to see how it works. First, let’s have a look at the vector\n\nvec &gt; 6\n\n [1] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\n\n\nAs we can see, it returns a logical vector with the same length as vec whose elements says whether it is true or false that the element in that position is greater than 6. When we pass a logical vector, such as this, to another vector through the brackets, R will return only the elements of the vector corresponding to a true value in the logical vector.\nTo make this more clear, we could even assign a name to this logical vector and pass the name to the vector, like so:\n\nfilter &lt;- vec &gt; 6\nfilter\n\n [1] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\n\nvec[filter]\n\n[1]  7  8  9 10",
    "crumbs": [
      "R programming",
      "Introduction to R programming",
      "Vectors"
    ]
  },
  {
    "objectID": "vectors.html#two-useful-functions-to-generate-vectors",
    "href": "vectors.html#two-useful-functions-to-generate-vectors",
    "title": "Vectors",
    "section": "",
    "text": "Besides the function c() we have already seen that the colon operator from:to generates a sequence starting at from and ending at to. Another function that does the same job is seq(from, to, by = ). The parameter by specifies the increment of the sequence and its default value is 1. So, for example,\n\nseq(5, 16, by = 2)\n\n[1]  5  7  9 11 13 15\n\n\nAnother function that creates a vector is rep(x, times) which repeats the vector x times times.\n\nrep(c(1, 2), times = 3)\n\n[1] 1 2 1 2 1 2\n\n\nThe function rep has an alternative parameter each which repeats ‘each’ element of x each times. For example,\n\nrep(c(1, 2), each = 3)\n\n[1] 1 1 1 2 2 2",
    "crumbs": [
      "R programming",
      "Introduction to R programming",
      "Vectors"
    ]
  },
  {
    "objectID": "vectors.html#first-step-in-data-simulation",
    "href": "vectors.html#first-step-in-data-simulation",
    "title": "Vectors",
    "section": "",
    "text": "Sometimes instead of generating data with a pattern, we would like to simulate data. R is perfect for this job, as it has a very good implementation of all the most common and important statistical distributions needed. However, before we can simulate data, it is vital to say a few words about random data generation and reproducibility.\n\n\nAccording to Wikipedia, random number generation is a process by which, often by means of a random number generator (RGN), a sequence of numbers or symbols that cannot be reasonably predicted better than by random chance is generated. True random number generators are generally hardware based (for example by rolling a die). Software typically use a pseudo-random number generator (PRNG) which is an algorithm that generates a sequence of numbers that only looks random but that is in fact pre-determined. On Wikipedia there is long list of PRNGs, but for our scope, suffices it to say that the numbers that can be generated by R are in actual facts not random, but they would pass a random test, which means that they would look random from a mathematical point of view. If you want to know more about how R generates random numbers, you may wish to type help(\"RNG\") on your console.\n\n\n\nThis may look like a disadvantage, but it is actually a very important aspect of simulation. By means of the fact that random numbers are not-random after all, this means that if we “set a seed” we can then reproduce the exact random sequence again. This means that different user can perform the same simulation, obtaining the same result, as long as they use the same PRNG and they set the same seed.\nIn R the command to set the PRNG seed is set.seed().\nThis function needs to be assigned a number, the seed, which starts the sequence.\n\n\n\nLet’s see an example. Imagine we wish to roll a die. This means that we have a set of six possible outcomes (coded as 1 to 6), and by rolling a fair die we select one of them and all of them have the same probability (1 out of 6) to be selected. This can be done easily by sampling the set 1 to 6, i.e.\n\nset.seed(123)\nsample(1:6, 1)\n\n[1] 3\n\n\nImagine now we want to roll our die 10 times. This can be simulated using a similar code: we need to sample 10 times the set 1 to 6, but this sample must be with replacement. Thus we need to add the parameter replace = TRUE to the code to ensure that R samples with replacement. Let’s also set the same seed.\n\nset.seed(123)\nsample(1:6, 10, replace = TRUE)\n\n [1] 3 6 3 2 2 6 3 5 4 6\n\n\nWe may notice that having set the same seed, the first number is exactly the same as before.\n\n\n\n\n\n\nCaution\n\n\n\nA note of caution here: it is a good practice to set the seed every time we use a random generator function. In fact, once the seed has been set, the random function will use the PRGN in a specific way and different versions of the same function might use the PRNG in different ways. So once we access the PRNG again, it is good to always maintain control by choosing the seed, to ensure reproducibility.\n\n\n\n\n\nSuppose now we want to simulate a measurement (e.g. the temperature of a town). In this case we can’t sample from a population, but we need to use a statistical distribution. The statistical distribution that models a measurement is called the normal distribution and it has two parameters: the mean and the standard deviation. The mean represents the typical value of this measurement, and the standard deviation represent an approximation of the error made in taking this measurement.\nSo let’s run a simulation of 10 measurements of an average temperature of 18 degrees with a variability of 3 degrees.\n\nset.seed(101)\nrnorm(10, mean = 18, sd = 3)\n\n [1] 17.02189 19.65739 15.97517 18.64308 18.93231 21.52190 19.85637 17.66180\n [9] 20.75108 17.33022\n\n\nThis is way too accurate: let’s just round this to integers.\n\nset.seed(101)\nround(rnorm(10, mean = 18, sd = 3))\n\n [1] 17 20 16 19 19 22 20 18 21 17\n\n\nAnother very common distribution is the so called uniform distribution which gives the same probability to all numbers between a minimum and a maximum chosen numbers (defaults are min = 0 and max = 1). Let’s simulate 100 values from a uniform distribution:\n\nset.seed(111)\nrunif(100)\n\n  [1] 0.5929812845 0.7264811215 0.3704220036 0.5149238301 0.3776632159\n  [6] 0.4183373258 0.0106578451 0.5322952422 0.4321606164 0.0936815199\n [11] 0.5557799137 0.5902284889 0.0671411434 0.0475478533 0.1562025158\n [16] 0.4464277634 0.1714436871 0.9665342933 0.3106664298 0.6144663957\n [21] 0.4310607871 0.2855270915 0.3421513471 0.3866276275 0.9675274789\n [26] 0.3220267275 0.6532294548 0.2833034997 0.7874279192 0.5959206352\n [31] 0.0585964625 0.5098998600 0.4657924296 0.4693590938 0.3597453721\n [36] 0.7134103531 0.1163154817 0.7839926207 0.6421407105 0.8051009134\n [41] 0.6411978584 0.3284916454 0.6356909545 0.9285191579 0.5752422044\n [46] 0.3666838536 0.4366072204 0.8559219379 0.6279955737 0.7937756432\n [51] 0.7251648332 0.5850447209 0.0327716474 0.3329946804 0.9967166614\n [56] 0.5482733699 0.5758329388 0.4563152066 0.0965785654 0.8055401752\n [61] 0.0009253006 0.4667440471 0.1732608730 0.2592225648 0.9192820815\n [66] 0.2319295844 0.0525656715 0.3043926249 0.0117258150 0.3007076983\n [71] 0.8775839461 0.6652787277 0.4537648347 0.0533223320 0.6309068091\n [76] 0.4421851884 0.2673464869 0.9837744189 0.0951241532 0.7859691235\n [81] 0.1198521818 0.8812154671 0.1310980669 0.4003378763 0.0866140136\n [86] 0.3747997992 0.6847860171 0.7347726757 0.7709477365 0.5799853499\n [91] 0.5110989846 0.8529837073 0.6298211562 0.5790059080 0.7402492894\n [96] 0.3871497631 0.9935344572 0.3980894811 0.9750010339 0.8244822009\n\n\nThe table below shows the most common distributions with their syntax and a brief explanation.\n\n\n\n\n\n\n\n\nName\nSynatx\nExample of usage\n\n\n\n\nNormal distribution\nrnorm(n, mean = 0, sd = 1)\nThe normal distribution models measurements with mean mean and error sd\n\n\nUniform distribution\nrunif(n, min = 0, max = 1)\nThe uniform distribution is generally used to generate a sequence of random numbers\n\n\nBinomial distribution\nrbinom(n, size, prob)\nThe binomial distribution models the number of successes in size trials with probability of success prob\n\n\nPoisson distribution\nrpois(n, lambda)\nThe Poisson distribution is also called the “count” distribution: it models the number of events occurring at a constant rate in a given time frame. lambda is the mean number of events occurring.\n\n\nExponential distribution\nrexp(n, rate = 1)\nThe exponential distribution models the time to wait until the next event occurs, such as a failure or a success. rate is the average rate at which the events occur.\n\n\nGeometric distribution\nrgeom(n, prob)\nThe geometric distribution models the instant of first success in a sequence of trials with probability of success prob"
  },
  {
    "objectID": "vectors.html#first-steps-in-data-simulation",
    "href": "vectors.html#first-steps-in-data-simulation",
    "title": "Vectors",
    "section": "",
    "text": "Sometimes instead of generating data with a pattern, we would like to simulate data. R is perfect for this job, as it has a very good implementation of all the most common and important statistical distributions needed. However, before we can simulate data, it is vital to say a few words about random data generation and reproducibility.\n\n\nAccording to Wikipedia, random number generation is a process by which, often by means of a random number generator (RGN), a sequence of numbers or symbols that cannot be reasonably predicted better than by random chance is generated. True random number generators are generally hardware based (for example by rolling a die). Software typically use a pseudo-random number generator (PRNG) which is an algorithm that generates a sequence of numbers that only looks random but that is in fact pre-determined. On Wikipedia there is long list of PRNGs, but for our scope, suffices it to say that the numbers that can be generated by R are in actual facts not random, but they would pass a random test, which means that they would look random from a mathematical point of view. If you want to know more about how R generates random numbers, you may wish to type help(\"RNG\") on your console.\n\n\n\nThis may look like a disadvantage, but it is actually a very important aspect of simulation. By means of the fact that random numbers are not-random after all, this means that if we “set a seed” we can then reproduce the exact random sequence again. This means that different user can perform the same simulation, obtaining the same result, as long as they use the same PRNG and they set the same seed.\nIn R the command to set the PRNG seed is set.seed().\nThis function needs to be assigned a number, the seed, which starts the sequence.\n\n\n\nLet’s see an example. Imagine we wish to roll a die. This means that we have a set of six possible outcomes (coded as 1 to 6), and by rolling a fair die we select one of them and all of them have the same probability (1 out of 6) to be selected. This can be done easily by sampling the set 1 to 6, i.e.\n\nset.seed(123)\nsample(1:6, 1)\n\n[1] 3\n\n\nImagine now we want to roll our die 10 times. This can be simulated using a similar code: we need to sample 10 times the set 1 to 6, but this sample must be with replacement. Thus we need to add the parameter replace = TRUE to the code to ensure that R samples with replacement. Let’s also set the same seed.\n\nset.seed(123)\nsample(1:6, 10, replace = TRUE)\n\n [1] 3 6 3 2 2 6 3 5 4 6\n\n\nWe may notice that having set the same seed, the first number is exactly the same as before.\n\n\n\n\n\n\nCaution\n\n\n\nA note of caution here: it is a good practice to set the seed every time we use a random generator function. In fact, once the seed has been set, the random function will use the PRGN in a specific way and different versions of the same function might use the PRNG in different ways. So once we access the PRNG again, it is good to always maintain control by choosing the seed, to ensure reproducibility.\n\n\n\n\n\nSuppose now we want to simulate a measurement (e.g. the temperature of a town). In this case we can’t sample from a population, but we need to use a statistical distribution. The statistical distribution that models a measurement is called the normal distribution and it has two parameters: the mean and the standard deviation. The mean represents the typical value of this measurement, and the standard deviation represent an approximation of the error made in taking this measurement.\nSo let’s run a simulation of 10 measurements of an average temperature of 18 degrees with a variability of 3 degrees.\n\nset.seed(101)\nrnorm(10, mean = 18, sd = 3)\n\n [1] 17.02189 19.65739 15.97517 18.64308 18.93231 21.52190 19.85637 17.66180\n [9] 20.75108 17.33022\n\n\nThis is way too accurate: let’s just round this to integers.\n\nset.seed(101)\nround(rnorm(10, mean = 18, sd = 3))\n\n [1] 17 20 16 19 19 22 20 18 21 17\n\n\nAnother very common distribution is the so called uniform distribution which gives the same probability to all numbers between a minimum and a maximum chosen numbers (defaults are min = 0 and max = 1). Let’s simulate 100 values from a uniform distribution:\n\nset.seed(111)\nrunif(100)\n\n  [1] 0.5929812845 0.7264811215 0.3704220036 0.5149238301 0.3776632159\n  [6] 0.4183373258 0.0106578451 0.5322952422 0.4321606164 0.0936815199\n [11] 0.5557799137 0.5902284889 0.0671411434 0.0475478533 0.1562025158\n [16] 0.4464277634 0.1714436871 0.9665342933 0.3106664298 0.6144663957\n [21] 0.4310607871 0.2855270915 0.3421513471 0.3866276275 0.9675274789\n [26] 0.3220267275 0.6532294548 0.2833034997 0.7874279192 0.5959206352\n [31] 0.0585964625 0.5098998600 0.4657924296 0.4693590938 0.3597453721\n [36] 0.7134103531 0.1163154817 0.7839926207 0.6421407105 0.8051009134\n [41] 0.6411978584 0.3284916454 0.6356909545 0.9285191579 0.5752422044\n [46] 0.3666838536 0.4366072204 0.8559219379 0.6279955737 0.7937756432\n [51] 0.7251648332 0.5850447209 0.0327716474 0.3329946804 0.9967166614\n [56] 0.5482733699 0.5758329388 0.4563152066 0.0965785654 0.8055401752\n [61] 0.0009253006 0.4667440471 0.1732608730 0.2592225648 0.9192820815\n [66] 0.2319295844 0.0525656715 0.3043926249 0.0117258150 0.3007076983\n [71] 0.8775839461 0.6652787277 0.4537648347 0.0533223320 0.6309068091\n [76] 0.4421851884 0.2673464869 0.9837744189 0.0951241532 0.7859691235\n [81] 0.1198521818 0.8812154671 0.1310980669 0.4003378763 0.0866140136\n [86] 0.3747997992 0.6847860171 0.7347726757 0.7709477365 0.5799853499\n [91] 0.5110989846 0.8529837073 0.6298211562 0.5790059080 0.7402492894\n [96] 0.3871497631 0.9935344572 0.3980894811 0.9750010339 0.8244822009\n\n\nThe table below shows the most common distributions with their syntax and a brief explanation.\n\n\n\n\n\n\n\n\nName\nSynatx\nExample of usage\n\n\n\n\nNormal distribution\nrnorm(n, mean = 0, sd = 1)\nThe normal distribution models measurements with mean mean and error sd\n\n\nUniform distribution\nrunif(n, min = 0, max = 1)\nThe uniform distribution is generally used to generate a sequence of random numbers\n\n\nBinomial distribution\nrbinom(n, size, prob)\nThe binomial distribution models the number of successes in size trials with probability of success prob\n\n\nPoisson distribution\nrpois(n, lambda)\nThe Poisson distribution is also called the “count” distribution: it models the number of events occurring at a constant rate in a given time frame. lambda is the mean number of events occurring.\n\n\nExponential distribution\nrexp(n, rate = 1)\nThe exponential distribution models the time to wait until the next event occurs, such as a failure or a success. rate is the average rate at which the events occur.\n\n\nGeometric distribution\nrgeom(n, prob)\nThe geometric distribution models the instant of first success in a sequence of trials with probability of success prob",
    "crumbs": [
      "R programming",
      "Introduction to R programming",
      "Vectors"
    ]
  },
  {
    "objectID": "data-frames.html",
    "href": "data-frames.html",
    "title": "Data Frames",
    "section": "",
    "text": "Data frames are used to store tabular data in R. They are an important type of object and are used in a variety of statistical modelling applications.\nThe tidyverse meta-package has an enhanced version of data frame, called a tibble and an optimised set of functions designed to work effectively with data frames and tibbles.\nBefore we continue, it is therefore necessary to install, and load, the tidyverse.\n\n\nAnyone can create new R packages, but only when packages satisfy certain strict rules are they stored on CRAN. This ensures that packages stored on CRAN are reliable, have documentation and there is a support in place for the users. To install a package that lives on CRAN it suffices to type on the console install.packages(\"package_name\"). R will then install the package and all the dependencies needed to run the package.\nSo, to install the whole tidyverse we just have to type install.packages(\"tidyverse\").\nTo load a package (regardless of where it comes from), we need to use the command library(). So, to load the tidyverse we can just type in out script and run the code\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.4.4     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nThe outcome is pretty overwhelming! First we are informed that all the core tidyverse packages are correctly loaded: dplyr, forecats, ggplot2, lubridate, purrr, readr, stringr, tibble and tidyr. Then we are also informed that there are two functions that were already loaded from the package stats (a base R package automatically loaded by R), and they are now substituted by the homonym functions from dplyr. This might seem like a loss, but the stats functions are not lost, we only need to call them via their “long name”.\n\n\nThe long name of a function is composed by the name of the package where the function is stored, two colons (::) and the name of the function. So, to use the function filter() in stats we can type stats::filter(). Similarly, if we wanted to use the function read_csv() which lies in the package readr, we could just type readr::read_csv() without the needs to load the package readr in advance.\n\n\n\n\n\n\nTip\n\n\n\nIt is good practice to always load at the beginning of the script code the packages that are going to be used, even though, sometimes, we may end up using the long name for the sake of clarity, or to avoid conflicts between packages.\n\n\n\n\n\n\n\nQuoting from the tidyverse home page:\nThe tidyverse is an opinionated collection of R packages designed for data science. All packages share an underlying design philosophy, grammar, and data structures.\nAs we have seen by loading the tidyverse, this meta-package is composed of 9 packages, each with a specific function, to make the code more readable, effective and data analysis more enjoyable.\nThe first feature of the tidyverse that we want to get acquainted with is a tibble. Again, quoting from the tidyverse home page: “A tibble is a modern re-imagining of the data frame, keeping what time has proven to be effective, and throwing out what it has not. Tibbles are data.frames that are lazy and surly: they do less and complain more forcing you to confront problems earlier, typically leading to cleaner, more expressive code.”\n\n\n\nTibbles are represented as a special type of bivariate data sets, where every column may store different type of objects, but the overall length of each column must be the same. Tibbles may be thought of as two-by-two matrices, where the rows represent different items, and each column represents the variables that are recorded, or measured, for each item. Thus tibbles are the object that correctly represents a data set.\nTibbles are generally created by reading in a data set using the readr functions such as read_csv() or read_delim(). However, tibbles can also be created explicitly using the tibble() function. For example,\n\ntibble(\n    name = c(\"Alice\", \"Bob\", \"Charlie\"),\n    age = c(25, 31, 36),\n    salary = c(14000, 18000, 25000)\n)\n\n# A tibble: 3 × 3\n  name      age salary\n  &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt;\n1 Alice      25  14000\n2 Bob        31  18000\n3 Charlie    36  25000\n\n\nThis is easy however, only when the variables (name, age and salary are already stored in some vectors, and we wish to collate them together into a data frame). When we try to store them one by one, it is often more logical to assign the data row by row. This can be done with a variant of tibble called tribble(), which stands for “transpose tibble”. For example,\n\ntribble(\n    ~ name, ~ age, ~ salary,\n    \"Alice\", 25, 14000,\n    \"Bob\", 21, 18000,\n    \"Charlie\", 56, 25000\n)\n\n# A tibble: 3 × 3\n  name      age salary\n  &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt;\n1 Alice      25  14000\n2 Bob        21  18000\n3 Charlie    56  25000\n\n\nNote the presence of the symbol ~ before the names of the columns (i.e. the names of the variables) when defined using the tribble() function.\nGenerally speaking, the tribble() function works well when one wishes to write down the data directly, while the tibble() function works well to collect into a tibble different variables already stored into single vectors. For example, assume we have recorded the height (in cm) and the weight (in kg) of a sample of students and we have stored this information into the variables height and weight, like so:\n\nheight &lt;- c(163, 171, 159, 162, 161, 174, 177, 158, 164, 177)\nweight &lt;- c(65, 78, 73, 81, 83, 79, 80, 76, 82, 88)\n\nThen we can collect these variables into a tibble, like so:\n\nstudents &lt;- tibble(height, weight)\nstudents\n\n# A tibble: 10 × 2\n   height weight\n    &lt;dbl&gt;  &lt;dbl&gt;\n 1    163     65\n 2    171     78\n 3    159     73\n 4    162     81\n 5    161     83\n 6    174     79\n 7    177     80\n 8    158     76\n 9    164     82\n10    177     88\n\n\nNevertheless, it should be quite evident that when the data set is big, this is not the best way to create a data set. Before exploring how to import data sets into R, however, it may be worth exploring a few data sets.\n\n\n\nR contains several examples of data sets, some of which particularly interesting because they are data sets of historical value, like Edgar Anderson’s Iris data set. To see which data sets are included in R, we can use the command data(). This opens a new tab in RStudio showing the list of data sets included in base R.\nAny of these data sets can be called simply typing their name on the console (or running the corresponding code in the R script). However, data sets stored in R cannot be changed, and in order to have the flexibility to make changes, we may wish to save a copy in the memory. However, since the base R saves data sets as data.frame type, we may wish to transform them into a tibble, with the command as_tibble(), like so:\n\niris &lt;- as_tibble(iris)\niris\n\n# A tibble: 150 × 5\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n          &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;  \n 1          5.1         3.5          1.4         0.2 setosa \n 2          4.9         3            1.4         0.2 setosa \n 3          4.7         3.2          1.3         0.2 setosa \n 4          4.6         3.1          1.5         0.2 setosa \n 5          5           3.6          1.4         0.2 setosa \n 6          5.4         3.9          1.7         0.4 setosa \n 7          4.6         3.4          1.4         0.3 setosa \n 8          5           3.4          1.5         0.2 setosa \n 9          4.4         2.9          1.4         0.2 setosa \n10          4.9         3.1          1.5         0.1 setosa \n# ℹ 140 more rows\n\n\nNote that the data sets contains 150 rows, but one of the features of a tibble is that it shows only the first 10 rows. If we wish to see more (or less) rows, we can pass the tibble to the function print() and state the numbers of rows to print. For instance, to see the first three rows, we can use\n\nprint(iris, n = 3)\n\n# A tibble: 150 × 5\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n         &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;  \n1          5.1         3.5          1.4         0.2 setosa \n2          4.9         3            1.4         0.2 setosa \n3          4.7         3.2          1.3         0.2 setosa \n# ℹ 147 more rows\n\n\nIf we wish to see the structure of the variables of this data set, we can use the glimpse() function, which shows the list of the variables together with their type and the first few values of each of them. For example,\n\nglimpse(iris)\n\nRows: 150\nColumns: 5\n$ Sepal.Length &lt;dbl&gt; 5.1, 4.9, 4.7, 4.6, 5.0, 5.4, 4.6, 5.0, 4.4, 4.9, 5.4, 4.…\n$ Sepal.Width  &lt;dbl&gt; 3.5, 3.0, 3.2, 3.1, 3.6, 3.9, 3.4, 3.4, 2.9, 3.1, 3.7, 3.…\n$ Petal.Length &lt;dbl&gt; 1.4, 1.4, 1.3, 1.5, 1.4, 1.7, 1.4, 1.5, 1.4, 1.5, 1.5, 1.…\n$ Petal.Width  &lt;dbl&gt; 0.2, 0.2, 0.2, 0.2, 0.2, 0.4, 0.3, 0.2, 0.2, 0.1, 0.2, 0.…\n$ Species      &lt;fct&gt; setosa, setosa, setosa, setosa, setosa, setosa, setosa, s…\n\n\nWe have also already established that the function summary() is adaptable and its outcome depends on the type of object that we pass to it. Let’s see what happens when we pass a tibble to this function.\n\nsummary(iris)\n\n  Sepal.Length    Sepal.Width     Petal.Length    Petal.Width   \n Min.   :4.300   Min.   :2.000   Min.   :1.000   Min.   :0.100  \n 1st Qu.:5.100   1st Qu.:2.800   1st Qu.:1.600   1st Qu.:0.300  \n Median :5.800   Median :3.000   Median :4.350   Median :1.300  \n Mean   :5.843   Mean   :3.057   Mean   :3.758   Mean   :1.199  \n 3rd Qu.:6.400   3rd Qu.:3.300   3rd Qu.:5.100   3rd Qu.:1.800  \n Max.   :7.900   Max.   :4.400   Max.   :6.900   Max.   :2.500  \n       Species  \n setosa    :50  \n versicolor:50  \n virginica :50  \n                \n                \n                \n\n\nNicely, summary() returns a summary of each variable in the tibble, and each summary depends on the type of the variable.\nAnother nice data set stored in R is airquality, which shows the Daily air quality measurements in New York, May to September 1973. To store it as a tibble, let’s run the following\n\nairquality &lt;- as_tibble(airquality)\nairquality\n\n# A tibble: 153 × 6\n   Ozone Solar.R  Wind  Temp Month   Day\n   &lt;int&gt;   &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;\n 1    41     190   7.4    67     5     1\n 2    36     118   8      72     5     2\n 3    12     149  12.6    74     5     3\n 4    18     313  11.5    62     5     4\n 5    NA      NA  14.3    56     5     5\n 6    28      NA  14.9    66     5     6\n 7    23     299   8.6    65     5     7\n 8    19      99  13.8    59     5     8\n 9     8      19  20.1    61     5     9\n10    NA     194   8.6    69     5    10\n# ℹ 143 more rows\n\n\nHere we can notice a feature that we have not seen before: the presence of NA’s into the data set. NA is a special type of logical value which stands for “Not Available”. This represents a missing value. It is often the case that a data set is incomplete, i.e. that some of the data is not recorded, or it is lost. If these situations are saved as NA, R can keep track of the missing value and handle it accordingly. There are several functions in R that help dealing with missing values.\nAnother example of data set comes from the package ggplot2 (one of the tidyverse core packages) and it is called mpg; it contains the Fuel economy data from 1999 to 2008 for 38 popular models of cars. This is a data set stored into the tidyverse so it is already a tibble. To see it we can just call it, like so:\n\nmpg\n\n# A tibble: 234 × 11\n   manufacturer model      displ  year   cyl trans drv     cty   hwy fl    class\n   &lt;chr&gt;        &lt;chr&gt;      &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt;\n 1 audi         a4           1.8  1999     4 auto… f        18    29 p     comp…\n 2 audi         a4           1.8  1999     4 manu… f        21    29 p     comp…\n 3 audi         a4           2    2008     4 manu… f        20    31 p     comp…\n 4 audi         a4           2    2008     4 auto… f        21    30 p     comp…\n 5 audi         a4           2.8  1999     6 auto… f        16    26 p     comp…\n 6 audi         a4           2.8  1999     6 manu… f        18    26 p     comp…\n 7 audi         a4           3.1  2008     6 auto… f        18    27 p     comp…\n 8 audi         a4 quattro   1.8  1999     4 manu… 4        18    26 p     comp…\n 9 audi         a4 quattro   1.8  1999     4 auto… 4        16    25 p     comp…\n10 audi         a4 quattro   2    2008     4 manu… 4        20    28 p     comp…\n# ℹ 224 more rows\n\n\nAn interesting fact about this data set is the variety of variables stored in it. Let’s have a proper look with glimpse():\n\nglimpse(mpg)\n\nRows: 234\nColumns: 11\n$ manufacturer &lt;chr&gt; \"audi\", \"audi\", \"audi\", \"audi\", \"audi\", \"audi\", \"audi\", \"…\n$ model        &lt;chr&gt; \"a4\", \"a4\", \"a4\", \"a4\", \"a4\", \"a4\", \"a4\", \"a4 quattro\", \"…\n$ displ        &lt;dbl&gt; 1.8, 1.8, 2.0, 2.0, 2.8, 2.8, 3.1, 1.8, 1.8, 2.0, 2.0, 2.…\n$ year         &lt;int&gt; 1999, 1999, 2008, 2008, 1999, 1999, 2008, 1999, 1999, 200…\n$ cyl          &lt;int&gt; 4, 4, 4, 4, 6, 6, 6, 4, 4, 4, 4, 6, 6, 6, 6, 6, 6, 8, 8, …\n$ trans        &lt;chr&gt; \"auto(l5)\", \"manual(m5)\", \"manual(m6)\", \"auto(av)\", \"auto…\n$ drv          &lt;chr&gt; \"f\", \"f\", \"f\", \"f\", \"f\", \"f\", \"f\", \"4\", \"4\", \"4\", \"4\", \"4…\n$ cty          &lt;int&gt; 18, 21, 20, 21, 16, 18, 18, 18, 16, 20, 19, 15, 17, 17, 1…\n$ hwy          &lt;int&gt; 29, 29, 31, 30, 26, 26, 27, 26, 25, 28, 27, 25, 25, 25, 2…\n$ fl           &lt;chr&gt; \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p…\n$ class        &lt;chr&gt; \"compact\", \"compact\", \"compact\", \"compact\", \"compact\", \"c…\n\n\nLet’s also use summary() to have a look at a summary of these values.\n\nsummary(mpg)\n\n manufacturer          model               displ            year     \n Length:234         Length:234         Min.   :1.600   Min.   :1999  \n Class :character   Class :character   1st Qu.:2.400   1st Qu.:1999  \n Mode  :character   Mode  :character   Median :3.300   Median :2004  \n                                       Mean   :3.472   Mean   :2004  \n                                       3rd Qu.:4.600   3rd Qu.:2008  \n                                       Max.   :7.000   Max.   :2008  \n      cyl           trans               drv                 cty       \n Min.   :4.000   Length:234         Length:234         Min.   : 9.00  \n 1st Qu.:4.000   Class :character   Class :character   1st Qu.:14.00  \n Median :6.000   Mode  :character   Mode  :character   Median :17.00  \n Mean   :5.889                                         Mean   :16.86  \n 3rd Qu.:8.000                                         3rd Qu.:19.00  \n Max.   :8.000                                         Max.   :35.00  \n      hwy             fl               class          \n Min.   :12.00   Length:234         Length:234        \n 1st Qu.:18.00   Class :character   Class :character  \n Median :24.00   Mode  :character   Mode  :character  \n Mean   :23.44                                        \n 3rd Qu.:27.00                                        \n Max.   :44.00                                        \n\n\nA quick look shows that most of these summaries is little informative. For example, the number of cylinders, cyl, really not helpful to understand what is going on. Same for the model, which only tells us that there are 234 data, bat what is the distribution of the models?\nTo answer that, we need to explain R that some of these data are not just characters (or numbers), but they are “categorical data”, which R calls factors.\n\n\n\nFactors are categorical data, i.e. qualitative or non-numerical data. For instance, social class, primary diagnosis, tumor stage, Tanner stage of puberty, etc are all examples of categorical data. They are typically input using a numeric code, but they can also be stored as characters.\nSuch variables should always be specified as factor in R. This is the data structure that (among other things) makes it possible to assign meaningful names to the categories, instead of reading them as mere strings of characters (such as IDs).\nThe terminology is that a factor has a set of levels — say four levels for concreteness. Internally, a four-level factor consists of two items: (a) a vector of integers between 1 and 4, and (b) a character vector of length 4 containing strings describing what the four levels are. Let’s look at an example, before going back to the mpg data set.\n\npain &lt;- c(0, 3, 2, 2, 1)\nfpain &lt;- factor(pain, levels = 0:3)\nlevels(fpain) &lt;- c(\"none\", \"mild\", \"medium\", \"severe\")\n\npain\n\n[1] 0 3 2 2 1\n\nfpain\n\n[1] none   severe medium medium mild  \nLevels: none mild medium severe\n\n\nThe first command creates a numeric vector pain, encoding the pain levels of five patients. We wish to treat this as categorical variable, so we create a factor fpain from it using the function factor(). This is called with one argument in addition to pain, namely levels = 0:3, which indicates that the input coding uses the values 0 to 3. The latter can in principle be left out since R by default uses the values in pain, suitably sorted, but it is a good habit to retain it. The effect of the final line is that the level names are changed to the four specified character strings.\nNow let’s return to the mpg data set. We wish to convert the variable cyl to factor. To do so, let’s use some powerful features of the tidyverse, and in particular of the package dplyr. Precisely, we can “mutate” the variable cyl transforming it into a factor, using the function mutate(), like so:\n\nmpg &lt;- mutate(mpg, cyl = factor(cyl))\n\nWe can now see what happens calling the summary() again.\n\nsummary(mpg)\n\n manufacturer          model               displ            year      cyl   \n Length:234         Length:234         Min.   :1.600   Min.   :1999   4:81  \n Class :character   Class :character   1st Qu.:2.400   1st Qu.:1999   5: 4  \n Mode  :character   Mode  :character   Median :3.300   Median :2004   6:79  \n                                       Mean   :3.472   Mean   :2004   8:70  \n                                       3rd Qu.:4.600   3rd Qu.:2008         \n                                       Max.   :7.000   Max.   :2008         \n    trans               drv                 cty             hwy       \n Length:234         Length:234         Min.   : 9.00   Min.   :12.00  \n Class :character   Class :character   1st Qu.:14.00   1st Qu.:18.00  \n Mode  :character   Mode  :character   Median :17.00   Median :24.00  \n                                       Mean   :16.86   Mean   :23.44  \n                                       3rd Qu.:19.00   3rd Qu.:27.00  \n                                       Max.   :35.00   Max.   :44.00  \n      fl               class          \n Length:234         Length:234        \n Class :character   Class :character  \n Mode  :character   Mode  :character  \n                                      \n                                      \n                                      \n\n\nNow, correctly, R recognises that the number of cylinders are not just numbers, but they are actually factors, so instead of working out the median and the five-number summary, it counts how many times each of these level occurs.\nIf we wish to do the same to model, trans, drv, fl and class, we can use a lovely convenience function called across(), which will apply a given function across all variables that are passed through as a vector of variables, like so:\n\nmpg &lt;- mutate(mpg, across(c(model, trans, drv, fl, class), factor))\n\nLet’s see the result with glimpse() first and summary() afterwards.\n\nglimpse(mpg)\n\nRows: 234\nColumns: 11\n$ manufacturer &lt;chr&gt; \"audi\", \"audi\", \"audi\", \"audi\", \"audi\", \"audi\", \"audi\", \"…\n$ model        &lt;fct&gt; a4, a4, a4, a4, a4, a4, a4, a4 quattro, a4 quattro, a4 qu…\n$ displ        &lt;dbl&gt; 1.8, 1.8, 2.0, 2.0, 2.8, 2.8, 3.1, 1.8, 1.8, 2.0, 2.0, 2.…\n$ year         &lt;int&gt; 1999, 1999, 2008, 2008, 1999, 1999, 2008, 1999, 1999, 200…\n$ cyl          &lt;fct&gt; 4, 4, 4, 4, 6, 6, 6, 4, 4, 4, 4, 6, 6, 6, 6, 6, 6, 8, 8, …\n$ trans        &lt;fct&gt; auto(l5), manual(m5), manual(m6), auto(av), auto(l5), man…\n$ drv          &lt;fct&gt; f, f, f, f, f, f, f, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, r, …\n$ cty          &lt;int&gt; 18, 21, 20, 21, 16, 18, 18, 18, 16, 20, 19, 15, 17, 17, 1…\n$ hwy          &lt;int&gt; 29, 29, 31, 30, 26, 26, 27, 26, 25, 28, 27, 25, 25, 25, 2…\n$ fl           &lt;fct&gt; p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, r, …\n$ class        &lt;fct&gt; compact, compact, compact, compact, compact, compact, com…\n\n\nWe can see here that the variables we have mutated across now are all labelled as “factors” (fct). Let’s see the summary as well now:\n\nsummary(mpg)\n\n manufacturer                       model         displ            year     \n Length:234         caravan 2wd        : 11   Min.   :1.600   Min.   :1999  \n Class :character   ram 1500 pickup 4wd: 10   1st Qu.:2.400   1st Qu.:1999  \n Mode  :character   civic              :  9   Median :3.300   Median :2004  \n                    dakota pickup 4wd  :  9   Mean   :3.472   Mean   :2004  \n                    jetta              :  9   3rd Qu.:4.600   3rd Qu.:2008  \n                    mustang            :  9   Max.   :7.000   Max.   :2008  \n                    (Other)            :177                                 \n cyl           trans    drv          cty             hwy        fl     \n 4:81   auto(l4)  :83   4:103   Min.   : 9.00   Min.   :12.00   c:  1  \n 5: 4   manual(m5):58   f:106   1st Qu.:14.00   1st Qu.:18.00   d:  5  \n 6:79   auto(l5)  :39   r: 25   Median :17.00   Median :24.00   e:  8  \n 8:70   manual(m6):19           Mean   :16.86   Mean   :23.44   p: 52  \n        auto(s6)  :16           3rd Qu.:19.00   3rd Qu.:27.00   r:168  \n        auto(l6)  : 6           Max.   :35.00   Max.   :44.00          \n        (Other)   :13                                                  \n        class   \n 2seater   : 5  \n compact   :47  \n midsize   :41  \n minivan   :11  \n pickup    :33  \n subcompact:35  \n suv       :62  \n\n\nThis is actually much more informative.",
    "crumbs": [
      "R programming",
      "Introduction to R programming",
      "Data Frames"
    ]
  },
  {
    "objectID": "data-frames.html#the-tidyverse",
    "href": "data-frames.html#the-tidyverse",
    "title": "Data Frames",
    "section": "",
    "text": "Quoting from the tidyverse home page:\nThe tidyverse is an opinionated collection of R packages designed for data science. All packages share an underlying design philosophy, grammar, and data structures.\nAs we have seen by loading the tidyverse, this meta-package is composed of 9 packages, each with a specific function, to make the code more readable, effective and data analysis more enjoyable.\nThe first feature of the tidyverse that we want to get acquainted with is a tibble. Again, quoting from the tidyverse home page: “A tibble is a modern re-imagining of the data frame, keeping what time has proven to be effective, and throwing out what it has not. Tibbles are data.frames that are lazy and surly: they do less and complain more forcing you to confront problems earlier, typically leading to cleaner, more expressive code.”",
    "crumbs": [
      "R programming",
      "Introduction to R programming",
      "Data Frames"
    ]
  },
  {
    "objectID": "data-frames.html#tibbles",
    "href": "data-frames.html#tibbles",
    "title": "Data Frames",
    "section": "",
    "text": "Tibbles are represented as a special type of bivariate data sets, where every column may store different type of objects, but the overall length of each column must be the same. Tibbles may be thought of as two-by-two matrices, where the rows represent different items, and each column represents the variables that are recorded, or measured, for each item. Thus tibbles are the object that correctly represents a data set.\nTibbles are generally created by reading in a data set using the readr functions such as read_csv() or read_delim(). However, tibbles can also be created explicitly using the tibble() function. For example,\n\ntibble(\n    name = c(\"Alice\", \"Bob\", \"Charlie\"),\n    age = c(25, 31, 36),\n    salary = c(14000, 18000, 25000)\n)\n\n# A tibble: 3 × 3\n  name      age salary\n  &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt;\n1 Alice      25  14000\n2 Bob        31  18000\n3 Charlie    36  25000\n\n\nThis is easy however, only when the variables (name, age and salary are already stored in some vectors, and we wish to collate them together into a data frame). When we try to store them one by one, it is often more logical to assign the data row by row. This can be done with a variant of tibble called tribble(), which stands for “transpose tibble”. For example,\n\ntribble(\n    ~ name, ~ age, ~ salary,\n    \"Alice\", 25, 14000,\n    \"Bob\", 21, 18000,\n    \"Charlie\", 56, 25000\n)\n\n# A tibble: 3 × 3\n  name      age salary\n  &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt;\n1 Alice      25  14000\n2 Bob        21  18000\n3 Charlie    56  25000\n\n\nNote the presence of the symbol ~ before the names of the columns (i.e. the names of the variables) when defined using the tribble() function.\nGenerally speaking, the tribble() function works well when one wishes to write down the data directly, while the tibble() function works well to collect into a tibble different variables already stored into single vectors. For example, assume we have recorded the height (in cm) and the weight (in kg) of a sample of students and we have stored this information into the variables height and weight, like so:\n\nheight &lt;- c(163, 171, 159, 162, 161, 174, 177, 158, 164, 177)\nweight &lt;- c(65, 78, 73, 81, 83, 79, 80, 76, 82, 88)\n\nThen we can collect these variables into a tibble, like so:\n\nstudents &lt;- tibble(height, weight)\nstudents\n\n# A tibble: 10 × 2\n   height weight\n    &lt;dbl&gt;  &lt;dbl&gt;\n 1    163     65\n 2    171     78\n 3    159     73\n 4    162     81\n 5    161     83\n 6    174     79\n 7    177     80\n 8    158     76\n 9    164     82\n10    177     88\n\n\nNevertheless, it should be quite evident that when the data set is big, this is not the best way to create a data set. Before exploring how to import data sets into R, however, it may be worth exploring a few data sets.",
    "crumbs": [
      "R programming",
      "Introduction to R programming",
      "Data Frames"
    ]
  },
  {
    "objectID": "data-frames.html#installing-and-loading-packages-in-r",
    "href": "data-frames.html#installing-and-loading-packages-in-r",
    "title": "Data Frames",
    "section": "",
    "text": "Anyone can create new R packages, but only when packages satisfy certain strict rules are they stored on CRAN. This ensures that packages stored on CRAN are reliable, have documentation and there is a support in place for the users. To install a package that lives on CRAN it suffices to type on the console install.packages(\"package_name\"). R will then install the package and all the dependencies needed to run the package.\nSo, to install the whole tidyverse we just have to type install.packages(\"tidyverse\").\nTo load a package (regardless of where it comes from), we need to use the command library(). So, to load the tidyverse we can just type in out script and run the code\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.4.4     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nThe outcome is pretty overwhelming! First we are informed that all the core tidyverse packages are correctly loaded: dplyr, forecats, ggplot2, lubridate, purrr, readr, stringr, tibble and tidyr. Then we are also informed that there are two functions that were already loaded from the package stats (a base R package automatically loaded by R), and they are now substituted by the homonym functions from dplyr. This might seem like a loss, but the stats functions are not lost, we only need to call them via their “long name”.\n\n\nThe long name of a function is composed by the name of the package where the function is stored, two colons (::) and the name of the function. So, to use the function filter() in stats we can type stats::filter(). Similarly, if we wanted to use the function read_csv() which lies in the package readr, we could just type readr::read_csv() without the needs to load the package readr in advance.\n\n\n\n\n\n\nTip\n\n\n\nIt is good practice to always load at the beginning of the script code the packages that are going to be used, even though, sometimes, we may end up using the long name for the sake of clarity, or to avoid conflicts between packages.",
    "crumbs": [
      "R programming",
      "Introduction to R programming",
      "Data Frames"
    ]
  },
  {
    "objectID": "data-frames.html#examples-of-data-sets",
    "href": "data-frames.html#examples-of-data-sets",
    "title": "Data Frames",
    "section": "",
    "text": "R contains several examples of data sets, some of which particularly interesting because they are data sets of historical value, like Edgar Anderson’s Iris data set. To see which data sets are included in R, we can use the command data(). This opens a new tab in RStudio showing the list of data sets included in base R.\nAny of these data sets can be called simply typing their name on the console (or running the corresponding code in the R script). However, data sets stored in R cannot be changed, and in order to have the flexibility to make changes, we may wish to save a copy in the memory. However, since the base R saves data sets as data.frame type, we may wish to transform them into a tibble, with the command as_tibble(), like so:\n\niris &lt;- as_tibble(iris)\niris\n\n# A tibble: 150 × 5\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n          &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;  \n 1          5.1         3.5          1.4         0.2 setosa \n 2          4.9         3            1.4         0.2 setosa \n 3          4.7         3.2          1.3         0.2 setosa \n 4          4.6         3.1          1.5         0.2 setosa \n 5          5           3.6          1.4         0.2 setosa \n 6          5.4         3.9          1.7         0.4 setosa \n 7          4.6         3.4          1.4         0.3 setosa \n 8          5           3.4          1.5         0.2 setosa \n 9          4.4         2.9          1.4         0.2 setosa \n10          4.9         3.1          1.5         0.1 setosa \n# ℹ 140 more rows\n\n\nNote that the data sets contains 150 rows, but one of the features of a tibble is that it shows only the first 10 rows. If we wish to see more (or less) rows, we can pass the tibble to the function print() and state the numbers of rows to print. For instance, to see the first three rows, we can use\n\nprint(iris, n = 3)\n\n# A tibble: 150 × 5\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n         &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;  \n1          5.1         3.5          1.4         0.2 setosa \n2          4.9         3            1.4         0.2 setosa \n3          4.7         3.2          1.3         0.2 setosa \n# ℹ 147 more rows\n\n\nIf we wish to see the structure of the variables of this data set, we can use the glimpse() function, which shows the list of the variables together with their type and the first few values of each of them. For example,\n\nglimpse(iris)\n\nRows: 150\nColumns: 5\n$ Sepal.Length &lt;dbl&gt; 5.1, 4.9, 4.7, 4.6, 5.0, 5.4, 4.6, 5.0, 4.4, 4.9, 5.4, 4.…\n$ Sepal.Width  &lt;dbl&gt; 3.5, 3.0, 3.2, 3.1, 3.6, 3.9, 3.4, 3.4, 2.9, 3.1, 3.7, 3.…\n$ Petal.Length &lt;dbl&gt; 1.4, 1.4, 1.3, 1.5, 1.4, 1.7, 1.4, 1.5, 1.4, 1.5, 1.5, 1.…\n$ Petal.Width  &lt;dbl&gt; 0.2, 0.2, 0.2, 0.2, 0.2, 0.4, 0.3, 0.2, 0.2, 0.1, 0.2, 0.…\n$ Species      &lt;fct&gt; setosa, setosa, setosa, setosa, setosa, setosa, setosa, s…\n\n\nWe have also already established that the function summary() is adaptable and its outcome depends on the type of object that we pass to it. Let’s see what happens when we pass a tibble to this function.\n\nsummary(iris)\n\n  Sepal.Length    Sepal.Width     Petal.Length    Petal.Width   \n Min.   :4.300   Min.   :2.000   Min.   :1.000   Min.   :0.100  \n 1st Qu.:5.100   1st Qu.:2.800   1st Qu.:1.600   1st Qu.:0.300  \n Median :5.800   Median :3.000   Median :4.350   Median :1.300  \n Mean   :5.843   Mean   :3.057   Mean   :3.758   Mean   :1.199  \n 3rd Qu.:6.400   3rd Qu.:3.300   3rd Qu.:5.100   3rd Qu.:1.800  \n Max.   :7.900   Max.   :4.400   Max.   :6.900   Max.   :2.500  \n       Species  \n setosa    :50  \n versicolor:50  \n virginica :50  \n                \n                \n                \n\n\nNicely, summary() returns a summary of each variable in the tibble, and each summary depends on the type of the variable.\nAnother nice data set stored in R is airquality, which shows the Daily air quality measurements in New York, May to September 1973. To store it as a tibble, let’s run the following\n\nairquality &lt;- as_tibble(airquality)\nairquality\n\n# A tibble: 153 × 6\n   Ozone Solar.R  Wind  Temp Month   Day\n   &lt;int&gt;   &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;\n 1    41     190   7.4    67     5     1\n 2    36     118   8      72     5     2\n 3    12     149  12.6    74     5     3\n 4    18     313  11.5    62     5     4\n 5    NA      NA  14.3    56     5     5\n 6    28      NA  14.9    66     5     6\n 7    23     299   8.6    65     5     7\n 8    19      99  13.8    59     5     8\n 9     8      19  20.1    61     5     9\n10    NA     194   8.6    69     5    10\n# ℹ 143 more rows\n\n\nHere we can notice a feature that we have not seen before: the presence of NA’s into the data set. NA is a special type of logical value which stands for “Not Available”. This represents a missing value. It is often the case that a data set is incomplete, i.e. that some of the data is not recorded, or it is lost. If these situations are saved as NA, R can keep track of the missing value and handle it accordingly. There are several functions in R that help dealing with missing values.\nAnother example of data set comes from the package ggplot2 (one of the tidyverse core packages) and it is called mpg; it contains the Fuel economy data from 1999 to 2008 for 38 popular models of cars. This is a data set stored into the tidyverse so it is already a tibble. To see it we can just call it, like so:\n\nmpg\n\n# A tibble: 234 × 11\n   manufacturer model      displ  year   cyl trans drv     cty   hwy fl    class\n   &lt;chr&gt;        &lt;chr&gt;      &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt;\n 1 audi         a4           1.8  1999     4 auto… f        18    29 p     comp…\n 2 audi         a4           1.8  1999     4 manu… f        21    29 p     comp…\n 3 audi         a4           2    2008     4 manu… f        20    31 p     comp…\n 4 audi         a4           2    2008     4 auto… f        21    30 p     comp…\n 5 audi         a4           2.8  1999     6 auto… f        16    26 p     comp…\n 6 audi         a4           2.8  1999     6 manu… f        18    26 p     comp…\n 7 audi         a4           3.1  2008     6 auto… f        18    27 p     comp…\n 8 audi         a4 quattro   1.8  1999     4 manu… 4        18    26 p     comp…\n 9 audi         a4 quattro   1.8  1999     4 auto… 4        16    25 p     comp…\n10 audi         a4 quattro   2    2008     4 manu… 4        20    28 p     comp…\n# ℹ 224 more rows\n\n\nAn interesting fact about this data set is the variety of variables stored in it. Let’s have a proper look with glimpse():\n\nglimpse(mpg)\n\nRows: 234\nColumns: 11\n$ manufacturer &lt;chr&gt; \"audi\", \"audi\", \"audi\", \"audi\", \"audi\", \"audi\", \"audi\", \"…\n$ model        &lt;chr&gt; \"a4\", \"a4\", \"a4\", \"a4\", \"a4\", \"a4\", \"a4\", \"a4 quattro\", \"…\n$ displ        &lt;dbl&gt; 1.8, 1.8, 2.0, 2.0, 2.8, 2.8, 3.1, 1.8, 1.8, 2.0, 2.0, 2.…\n$ year         &lt;int&gt; 1999, 1999, 2008, 2008, 1999, 1999, 2008, 1999, 1999, 200…\n$ cyl          &lt;int&gt; 4, 4, 4, 4, 6, 6, 6, 4, 4, 4, 4, 6, 6, 6, 6, 6, 6, 8, 8, …\n$ trans        &lt;chr&gt; \"auto(l5)\", \"manual(m5)\", \"manual(m6)\", \"auto(av)\", \"auto…\n$ drv          &lt;chr&gt; \"f\", \"f\", \"f\", \"f\", \"f\", \"f\", \"f\", \"4\", \"4\", \"4\", \"4\", \"4…\n$ cty          &lt;int&gt; 18, 21, 20, 21, 16, 18, 18, 18, 16, 20, 19, 15, 17, 17, 1…\n$ hwy          &lt;int&gt; 29, 29, 31, 30, 26, 26, 27, 26, 25, 28, 27, 25, 25, 25, 2…\n$ fl           &lt;chr&gt; \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p…\n$ class        &lt;chr&gt; \"compact\", \"compact\", \"compact\", \"compact\", \"compact\", \"c…\n\n\nLet’s also use summary() to have a look at a summary of these values.\n\nsummary(mpg)\n\n manufacturer          model               displ            year     \n Length:234         Length:234         Min.   :1.600   Min.   :1999  \n Class :character   Class :character   1st Qu.:2.400   1st Qu.:1999  \n Mode  :character   Mode  :character   Median :3.300   Median :2004  \n                                       Mean   :3.472   Mean   :2004  \n                                       3rd Qu.:4.600   3rd Qu.:2008  \n                                       Max.   :7.000   Max.   :2008  \n      cyl           trans               drv                 cty       \n Min.   :4.000   Length:234         Length:234         Min.   : 9.00  \n 1st Qu.:4.000   Class :character   Class :character   1st Qu.:14.00  \n Median :6.000   Mode  :character   Mode  :character   Median :17.00  \n Mean   :5.889                                         Mean   :16.86  \n 3rd Qu.:8.000                                         3rd Qu.:19.00  \n Max.   :8.000                                         Max.   :35.00  \n      hwy             fl               class          \n Min.   :12.00   Length:234         Length:234        \n 1st Qu.:18.00   Class :character   Class :character  \n Median :24.00   Mode  :character   Mode  :character  \n Mean   :23.44                                        \n 3rd Qu.:27.00                                        \n Max.   :44.00                                        \n\n\nA quick look shows that most of these summaries is little informative. For example, the number of cylinders, cyl, really not helpful to understand what is going on. Same for the model, which only tells us that there are 234 data, bat what is the distribution of the models?\nTo answer that, we need to explain R that some of these data are not just characters (or numbers), but they are “categorical data”, which R calls factors.",
    "crumbs": [
      "R programming",
      "Introduction to R programming",
      "Data Frames"
    ]
  },
  {
    "objectID": "data-frames.html#factors",
    "href": "data-frames.html#factors",
    "title": "Data Frames",
    "section": "",
    "text": "Factors are categorical data, i.e. qualitative or non-numerical data. For instance, social class, primary diagnosis, tumor stage, Tanner stage of puberty, etc are all examples of categorical data. They are typically input using a numeric code, but they can also be stored as characters.\nSuch variables should always be specified as factor in R. This is the data structure that (among other things) makes it possible to assign meaningful names to the categories, instead of reading them as mere strings of characters (such as IDs).\nThe terminology is that a factor has a set of levels — say four levels for concreteness. Internally, a four-level factor consists of two items: (a) a vector of integers between 1 and 4, and (b) a character vector of length 4 containing strings describing what the four levels are. Let’s look at an example, before going back to the mpg data set.\n\npain &lt;- c(0, 3, 2, 2, 1)\nfpain &lt;- factor(pain, levels = 0:3)\nlevels(fpain) &lt;- c(\"none\", \"mild\", \"medium\", \"severe\")\n\npain\n\n[1] 0 3 2 2 1\n\nfpain\n\n[1] none   severe medium medium mild  \nLevels: none mild medium severe\n\n\nThe first command creates a numeric vector pain, encoding the pain levels of five patients. We wish to treat this as categorical variable, so we create a factor fpain from it using the function factor(). This is called with one argument in addition to pain, namely levels = 0:3, which indicates that the input coding uses the values 0 to 3. The latter can in principle be left out since R by default uses the values in pain, suitably sorted, but it is a good habit to retain it. The effect of the final line is that the level names are changed to the four specified character strings.\nNow let’s return to the mpg data set. We wish to convert the variable cyl to factor. To do so, let’s use some powerful features of the tidyverse, and in particular of the package dplyr. Precisely, we can “mutate” the variable cyl transforming it into a factor, using the function mutate(), like so:\n\nmpg &lt;- mutate(mpg, cyl = factor(cyl))\n\nWe can now see what happens calling the summary() again.\n\nsummary(mpg)\n\n manufacturer          model               displ            year      cyl   \n Length:234         Length:234         Min.   :1.600   Min.   :1999   4:81  \n Class :character   Class :character   1st Qu.:2.400   1st Qu.:1999   5: 4  \n Mode  :character   Mode  :character   Median :3.300   Median :2004   6:79  \n                                       Mean   :3.472   Mean   :2004   8:70  \n                                       3rd Qu.:4.600   3rd Qu.:2008         \n                                       Max.   :7.000   Max.   :2008         \n    trans               drv                 cty             hwy       \n Length:234         Length:234         Min.   : 9.00   Min.   :12.00  \n Class :character   Class :character   1st Qu.:14.00   1st Qu.:18.00  \n Mode  :character   Mode  :character   Median :17.00   Median :24.00  \n                                       Mean   :16.86   Mean   :23.44  \n                                       3rd Qu.:19.00   3rd Qu.:27.00  \n                                       Max.   :35.00   Max.   :44.00  \n      fl               class          \n Length:234         Length:234        \n Class :character   Class :character  \n Mode  :character   Mode  :character  \n                                      \n                                      \n                                      \n\n\nNow, correctly, R recognises that the number of cylinders are not just numbers, but they are actually factors, so instead of working out the median and the five-number summary, it counts how many times each of these level occurs.\nIf we wish to do the same to model, trans, drv, fl and class, we can use a lovely convenience function called across(), which will apply a given function across all variables that are passed through as a vector of variables, like so:\n\nmpg &lt;- mutate(mpg, across(c(model, trans, drv, fl, class), factor))\n\nLet’s see the result with glimpse() first and summary() afterwards.\n\nglimpse(mpg)\n\nRows: 234\nColumns: 11\n$ manufacturer &lt;chr&gt; \"audi\", \"audi\", \"audi\", \"audi\", \"audi\", \"audi\", \"audi\", \"…\n$ model        &lt;fct&gt; a4, a4, a4, a4, a4, a4, a4, a4 quattro, a4 quattro, a4 qu…\n$ displ        &lt;dbl&gt; 1.8, 1.8, 2.0, 2.0, 2.8, 2.8, 3.1, 1.8, 1.8, 2.0, 2.0, 2.…\n$ year         &lt;int&gt; 1999, 1999, 2008, 2008, 1999, 1999, 2008, 1999, 1999, 200…\n$ cyl          &lt;fct&gt; 4, 4, 4, 4, 6, 6, 6, 4, 4, 4, 4, 6, 6, 6, 6, 6, 6, 8, 8, …\n$ trans        &lt;fct&gt; auto(l5), manual(m5), manual(m6), auto(av), auto(l5), man…\n$ drv          &lt;fct&gt; f, f, f, f, f, f, f, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, r, …\n$ cty          &lt;int&gt; 18, 21, 20, 21, 16, 18, 18, 18, 16, 20, 19, 15, 17, 17, 1…\n$ hwy          &lt;int&gt; 29, 29, 31, 30, 26, 26, 27, 26, 25, 28, 27, 25, 25, 25, 2…\n$ fl           &lt;fct&gt; p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, r, …\n$ class        &lt;fct&gt; compact, compact, compact, compact, compact, compact, com…\n\n\nWe can see here that the variables we have mutated across now are all labelled as “factors” (fct). Let’s see the summary as well now:\n\nsummary(mpg)\n\n manufacturer                       model         displ            year     \n Length:234         caravan 2wd        : 11   Min.   :1.600   Min.   :1999  \n Class :character   ram 1500 pickup 4wd: 10   1st Qu.:2.400   1st Qu.:1999  \n Mode  :character   civic              :  9   Median :3.300   Median :2004  \n                    dakota pickup 4wd  :  9   Mean   :3.472   Mean   :2004  \n                    jetta              :  9   3rd Qu.:4.600   3rd Qu.:2008  \n                    mustang            :  9   Max.   :7.000   Max.   :2008  \n                    (Other)            :177                                 \n cyl           trans    drv          cty             hwy        fl     \n 4:81   auto(l4)  :83   4:103   Min.   : 9.00   Min.   :12.00   c:  1  \n 5: 4   manual(m5):58   f:106   1st Qu.:14.00   1st Qu.:18.00   d:  5  \n 6:79   auto(l5)  :39   r: 25   Median :17.00   Median :24.00   e:  8  \n 8:70   manual(m6):19           Mean   :16.86   Mean   :23.44   p: 52  \n        auto(s6)  :16           3rd Qu.:19.00   3rd Qu.:27.00   r:168  \n        auto(l6)  : 6           Max.   :35.00   Max.   :44.00          \n        (Other)   :13                                                  \n        class   \n 2seater   : 5  \n compact   :47  \n midsize   :41  \n minivan   :11  \n pickup    :33  \n subcompact:35  \n suv       :62  \n\n\nThis is actually much more informative.",
    "crumbs": [
      "R programming",
      "Introduction to R programming",
      "Data Frames"
    ]
  },
  {
    "objectID": "data-frames.html#some-advanced-features-of-tidyverse",
    "href": "data-frames.html#some-advanced-features-of-tidyverse",
    "title": "Data Frames",
    "section": "",
    "text": "Before we can start learning all the beautiful and so helpful functions in the tidyverse, it becomes absolutely vital to talk about the philosophy of the tidyverse. The functions in tidyverse are generally defined with a verb (e.g. select, filter, mutate, rename, arrange, etc) and we generally take a data set, stored as a data frame or a tibble, and we apply one of these verb, then another and then another and so on, until we get what we need. The coding equivalent of the adverb “then” is called a pipe. The pipe command is the coding equivalent of the composition of functions in maths.\nIn maths, if f(x) and g(x) are two functions, instead of writing g(f(x)), i.e. to take x apply f and then apply g. In symbols,\n\nx \\mapsto f(x) \\mapsto g\\big(f(x)\\big),\n\nIn R, we do something similar: instead of taking g(f(x)), we do x |&gt; f |&gt; g using the |&gt; (pipe) command. So, for example, to say\n\nmpg &lt;- mutate(mpg, cyl = factor(cyl))\n\nwe can write\n\nmpg &lt;- mpg"
  },
  {
    "objectID": "data-frames.html#getting-data-in-r",
    "href": "data-frames.html#getting-data-in-r",
    "title": "Data Frames",
    "section": "",
    "text": "There are useful base R functions to read data from external files or internet addresses, but we shall learn how to use their enhanced counterparts stored in the package readr which is one of the core packages of the tidyverse.\nUsually data are stored either in excel files or in CSV files (comma separated variable). Let’s start with the latter and suppose we want to store in R the content of the sheep data set on the course repository. This contains the height (in cm) and the weight (in kg) of a sample of sheep. To do so, providing the tidyverse is loaded, it suffices to run the command\n\nsheep &lt;- read_csv(\"https://raw.githubusercontent.com/acarpignani/R4DS/main/datasets/sheep.csv\")\n\nRows: 100 Columns: 2\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\ndbl (2): weight, height\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nsheep\n\n# A tibble: 100 × 2\n   weight height\n    &lt;dbl&gt;  &lt;dbl&gt;\n 1   75.2   56.3\n 2  102.    83.6\n 3   74.5   56.6\n 4   81.4   55.6\n 5   83.2   73.6\n 6   80.8   56.2\n 7   81.7   65.9\n 8   90.8   70.4\n 9  103.    66.3\n10  105.    74.0\n# ℹ 90 more rows\n\n\nWhat is the average weight and height of these sheep? We have now all the elements to respond. For example, we can call the function summary(). As we have seen this is an adaptable function and when we pass a tibble to it, it returns a summary of every variable in the tibble, like so:\n\nsummary(sheep)\n\n     weight           height     \n Min.   : 55.90   Min.   :40.57  \n 1st Qu.: 73.02   1st Qu.:57.53  \n Median : 81.78   Median :65.31  \n Mean   : 82.75   Mean   :65.02  \n 3rd Qu.: 91.02   3rd Qu.:72.19  \n Max.   :119.50   Max.   :90.05  \n\n\nLet’s load another data set, from our repository. This time we are interested in the data set containing information about the density of worms in some fields. Let’s call this data frame worms.\n\nworms &lt;- read_csv(\"https://raw.githubusercontent.com/acarpignani/R4DS/main/datasets/worms.csv\")\n\nRows: 20 Columns: 7\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (2): Field.Name, Vegetation\ndbl (4): Area, Slope, Soil.pH, Worm.density\nlgl (1): Damp\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nworms\n\n# A tibble: 20 × 7\n   Field.Name         Area Slope Vegetation Soil.pH Damp  Worm.density\n   &lt;chr&gt;             &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;        &lt;dbl&gt; &lt;lgl&gt;        &lt;dbl&gt;\n 1 Nashs.Field         3.6    11 Grassland      4.1 FALSE            4\n 2 Silwood.Bottom      5.1     2 Arable         5.2 FALSE            7\n 3 Nursery.Field       2.8     3 Grassland      4.3 FALSE            2\n 4 Rush.Meadow         2.4     5 Meadow         4.9 TRUE             5\n 5 Gunness.Thicket     3.8     0 Scrub          4.2 FALSE            6\n 6 Oak.Mead            3.1     2 Grassland      3.9 FALSE            2\n 7 Church.Field        3.5     3 Grassland      4.2 FALSE            3\n 8 Ashurst             2.1     0 Arable         4.8 FALSE            4\n 9 The.Orchard         1.9     0 Orchard        5.7 FALSE            9\n10 Rookery.Slope       1.5     4 Grassland      5   TRUE             7\n11 Garden.Wood         2.9    10 Scrub          5.2 FALSE            8\n12 North.Gravel        3.3     1 Grassland      4.1 FALSE            1\n13 South.Gravel        3.7     2 Grassland      4   FALSE            2\n14 Observatory.Ridge   1.8     6 Grassland      3.8 FALSE            0\n15 Pond.Field          4.1     0 Meadow         5   TRUE             6\n16 Water.Meadow        3.9     0 Meadow         4.9 TRUE             8\n17 Cheapside           2.2     8 Scrub          4.7 TRUE             4\n18 Pound.Hill          4.4     2 Arable         4.5 FALSE            5\n19 Gravel.Pit          2.9     1 Grassland      3.5 FALSE            1\n20 Farm.Wood           0.8    10 Scrub          5.1 TRUE             3\n\n\nLet’s try now to apply the summary() to this data set.\n\nsummary(worms)\n\n  Field.Name             Area           Slope        Vegetation       \n Length:20          Min.   :0.800   Min.   : 0.00   Length:20         \n Class :character   1st Qu.:2.175   1st Qu.: 0.75   Class :character  \n Mode  :character   Median :3.000   Median : 2.00   Mode  :character  \n                    Mean   :2.990   Mean   : 3.50                     \n                    3rd Qu.:3.725   3rd Qu.: 5.25                     \n                    Max.   :5.100   Max.   :11.00                     \n    Soil.pH         Damp          Worm.density \n Min.   :3.500   Mode :logical   Min.   :0.00  \n 1st Qu.:4.100   FALSE:14        1st Qu.:2.00  \n Median :4.600   TRUE :6         Median :4.00  \n Mean   :4.555                   Mean   :4.35  \n 3rd Qu.:5.000                   3rd Qu.:6.25  \n Max.   :5.700                   Max.   :9.00  \n\n\nThe variable Vegetation is another factor, so let’s transform it into a factor using again the mutate() function.\n\nworms &lt;- mutate(worms, Vegetation = factor(Vegetation))\nsummary(worms)\n\n  Field.Name             Area           Slope           Vegetation\n Length:20          Min.   :0.800   Min.   : 0.00   Arable   :3   \n Class :character   1st Qu.:2.175   1st Qu.: 0.75   Grassland:9   \n Mode  :character   Median :3.000   Median : 2.00   Meadow   :3   \n                    Mean   :2.990   Mean   : 3.50   Orchard  :1   \n                    3rd Qu.:3.725   3rd Qu.: 5.25   Scrub    :4   \n                    Max.   :5.100   Max.   :11.00                 \n    Soil.pH         Damp          Worm.density \n Min.   :3.500   Mode :logical   Min.   :0.00  \n 1st Qu.:4.100   FALSE:14        1st Qu.:2.00  \n Median :4.600   TRUE :6         Median :4.00  \n Mean   :4.555                   Mean   :4.35  \n 3rd Qu.:5.000                   3rd Qu.:6.25  \n Max.   :5.700                   Max.   :9.00",
    "crumbs": [
      "R programming",
      "Basics",
      "Data Frames"
    ]
  },
  {
    "objectID": "lists.html",
    "href": "lists.html",
    "title": "Lists",
    "section": "",
    "text": "Lists\nLists are a special type of vectors that can contain elements of different classes. Lists are a very important data type in R and you should get to know them well. On the other hand, lists are also a very complex topic, and before really understanding their usage, you must see a multitude of examples. Lists pair with a class of R functions called the “apply functions” and together they become an impressively powerful tool. We shall not discuss the base R apply functions but an enhanced version available in the tidyverse through the package purrr. Until then, let’s only briefly see how a list is defined and how to access its elements.\n\nCreating a list\nSuppose we have the following vectors:\n\nnum &lt;- c(4, 8, 15, 16, 23, 42)\nlgl &lt;- c(TRUE, FALSE, TRUE)\nchar &lt;- c(\"Jack\", \"Kate\", \"Charlie\", \"John\")\n\nTo put them into a list, we can just write:\n\nlst &lt;- list(num, lgl, char)\nlst\n\n[[1]]\n[1]  4  8 15 16 23 42\n\n[[2]]\n[1]  TRUE FALSE  TRUE\n\n[[3]]\n[1] \"Jack\"    \"Kate\"    \"Charlie\" \"John\"   \n\n\nYou will notice that the list() assigned numbers to each of the objects in the list, but we can also assign names in the following manner:\n\nlst &lt;- list(numbers = num, logicals = lgl, characters = char)\nlst\n\n$numbers\n[1]  4  8 15 16 23 42\n\n$logicals\n[1]  TRUE FALSE  TRUE\n\n$characters\n[1] \"Jack\"    \"Kate\"    \"Charlie\" \"John\"   \n\n\n\n\nAccessing the list\nWe can use the brackets [ ] to access the elements of a list. For example,\n\nlst[1]\n\n$numbers\n[1]  4  8 15 16 23 42\n\n\nNotice however that by doing so, R returns another list, with only one element (namely the vector called “numbers” with entries 4, 8, 15, 16, 23, 42). In order to grab this vector, we need to use the double brackets [[ ]], like so:\n\nlst[[1]]\n\n[1]  4  8 15 16 23 42\n\n\nAlternatively, but only when the elements of the list are named, we can use the $ operator, and call the name of the list directly, like so:\n\nlst$numbers\n\n[1]  4  8 15 16 23 42\n\n\nAlternatively, we can use the double brackets [[ ]] with the name of the element, like so:\n\nlst[[\"numbers\"]]\n\n[1]  4  8 15 16 23 42\n\n\nWe can also compose the brackets, to access the elements of a specific object in a list. For example,\n\nlst[[\"numbers\"]][3]\n\n[1] 15\n\n\n\n\nCombining lists\nWe can also combine two lists together in one. This can be done with the concatenation function c(). For example, take\n\nlst_1 &lt;- list(nums = 0:9, alpha = letters)\nlst_2 &lt;- list(bool = c(TRUE, FALSE), \n              week = c(\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"))\n# List 1\nlst_1\n\n$nums\n [1] 0 1 2 3 4 5 6 7 8 9\n\n$alpha\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\n# List 2\nlst_2\n\n$bool\n[1]  TRUE FALSE\n\n$week\n[1] \"Mon\" \"Tue\" \"Wed\" \"Thu\" \"Fri\" \"Sat\" \"Sun\"\n\n# Combined list\nlst &lt;- c(lst_1, lst_2)\nlst\n\n$nums\n [1] 0 1 2 3 4 5 6 7 8 9\n\n$alpha\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\n$bool\n[1]  TRUE FALSE\n\n$week\n[1] \"Mon\" \"Tue\" \"Wed\" \"Thu\" \"Fri\" \"Sat\" \"Sun\"\n\n\n\n\n\n\n\n\nNote\n\n\n\nNotice that we have used the variable letters to generate the letters of the alphabet, even though we have never defined this variable before. This is because letters is a build-in variable in R and it is loaded with base R.\n\n\n\n\nStructure of a list\nIn order to see the structure of a list, we can use the command str(). For example, with reference with the last list, lst, created:\n\nstr(lst)\n\nList of 4\n $ nums : int [1:10] 0 1 2 3 4 5 6 7 8 9\n $ alpha: chr [1:26] \"a\" \"b\" \"c\" \"d\" ...\n $ bool : logi [1:2] TRUE FALSE\n $ week : chr [1:7] \"Mon\" \"Tue\" \"Wed\" \"Thu\" ...\n\n\nThis command shows the names of the elements that compose the list, the dimensions of these elements, and the first few elements.",
    "crumbs": [
      "R programming",
      "Introduction to R programming",
      "Lists"
    ]
  },
  {
    "objectID": "matrices.html",
    "href": "matrices.html",
    "title": "Matrices",
    "section": "",
    "text": "We’ve learned about vectors which allow us to store indexed elements. A matrix will allow us to have a 2-dimensional data structure which contains elements consisting of the same data type.\nBefore introducing about matrices, however, we should recall a shortcut for quickly creating sequential numeric vectors. this can be quickly achieved using the colon notation : introduced in the section Vector indexing and slicing.\nFor example, to create the sequence of the numbers from 1 to 10, we can type\n\n1:10\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\n\n\nTo create an empty m by n matrix we can type matrix(nrow = m, ncol = n). This will generate a matrix of NA, like so:\n\nmatrix(nrow = 3, ncol = 5)\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]   NA   NA   NA   NA   NA\n[2,]   NA   NA   NA   NA   NA\n[3,]   NA   NA   NA   NA   NA\n\n\nIf we wish to create and populate a matrix at the same time, we can pass a vector with all the entries of the matrix. For example,\n\nmatrix(1:15, nrow = 3)\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    4    7   10   13\n[2,]    2    5    8   11   14\n[3,]    3    6    9   12   15\n\n\nIn this case, we don’t need to state both nrow and ncol because the total number of elements in the vector 1:15 gives this information. Notice that, by default, R populates the matrix “by column”, i.e. it fills in the first column, then it passes to the second, and so on. Sometimes, however, it is convenient to populate the matrix “by row” instead. To this end, it suffices to pass a further argument byrow = TRUE, like so:\n\nmatrix(1:15, nrow = 3, byrow = TRUE)\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    2    3    4    5\n[2,]    6    7    8    9   10\n[3,]   11   12   13   14   15\n\n\n\n\nWe can also store the rows (or the columns) of a matrix in different vectors and later combine them into a single matrix. For example, consider the following vectors below of stock prices for Google and Microsoft:\n\ngoog &lt;- c(450, 451, 452, 445, 468)\nmsft &lt;- c(230, 231, 232, 236, 228)\n\nstocks &lt;- c(goog, msft)\nstock_matrix &lt;- matrix(stocks, nrow = 2, byrow = TRUE)\nstock_matrix\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]  450  451  452  445  468\n[2,]  230  231  232  236  228\n\n\n\n\n\nNow that we have our matrix, it would be nice to name the rows and columns for reference. We can do this similarly to the names() function for vectors, but in this case we define colnames() and rownames(). Let’s apply these commands to the stock matrix we have defined before:\n\ndays &lt;- c(\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\")\nstock_names &lt;- c(\"GOOG\", \"MSFT\")\ncolnames(stock_matrix) &lt;- days\nrownames(stock_matrix) &lt;- stock_names\n\nstock_matrix\n\n     Mon Tue Wed Thu Fri\nGOOG 450 451 452 445 468\nMSFT 230 231 232 236 228\n\n\n\n\n\n\n\n\nImportant\n\n\n\nOne of the main features (and limitations) of matrices is that all values in a matrix must be of the same type. So, for example, one can create a matrix of double numbers, or a matrix of logical values, but we cannot take a matrix where one column has numbers and another has logical values. To do this, we need to use a data frame which is more general type of matrix, where the columns (but not the row) can have different types.\n\n\n\n\n\n\nJust like with vectors, we use the square bracket notation to select elements from a matrix. Since we have two dimensions to work with, we will use a comma to separate our indexing for each dimension.\nSo the syntax is then:\nexample_matrix[rows, columns]\nwhere the index notation (e.g. 1:5) is put in place of the rows or columns . If either rows or columns is left blank, then we are selecting all the rows and columns.\nLet’s work through some examples:\n\nmat &lt;- matrix(1:50, nrow = 5, byrow = TRUE)\n\nLet us select the first row:\n\nmat[1,]\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nLet us now select the first column:\n\nmat[,1]\n\n[1]  1 11 21 31 41\n\n\nLet us now select the first 3 rows:\n\nmat[1:3,]\n\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n[1,]    1    2    3    4    5    6    7    8    9    10\n[2,]   11   12   13   14   15   16   17   18   19    20\n[3,]   21   22   23   24   25   26   27   28   29    30\n\n\nLet us also take the top left 2 by 3 rectangle:\n\nmat[1:2, 1:3]\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]   11   12   13\n\n\nFinally, let’s take the last two columns:\n\nmat[,9:10]\n\n     [,1] [,2]\n[1,]    9   10\n[2,]   19   20\n[3,]   29   30\n[4,]   39   40\n[5,]   49   50",
    "crumbs": [
      "R programming",
      "Introduction to R programming",
      "Matrices"
    ]
  },
  {
    "objectID": "in-and-out.html",
    "href": "in-and-out.html",
    "title": "Getting data in and out of R",
    "section": "",
    "text": "Before we can describe how to import and export data in R, it becomes necessary to discuss a bit more in detail about R workflow. Let’s just start by describing good practice. When working at a project in R, using RStudio, it is convenient to always start a new Project, by clicking File &gt; New Project.\nOnce the project is created we can create scripts to store in the directory where the Project is located, and this is set by RStudio as the working directory where R is going to start from when it reads or writes files.\nTo see the working directory we can type\n\ngetwd()\n\nIf we wish to change the working directory manually (operation that we do not recommend) we can now type:\n\nsetwd(\"relative_path\")\n\nQuoting H wickham, once we are inside a project, we should only ever use relative paths, not absolute paths. A relative path, in fact, is relative to the working directory, i.e. the project home. This guarantees that, if two people share a project (e.g. by cloning a github repository), they both can run the code regardless of the actual location where that repository is cloned.\n\n\n\nThere are useful base R functions to read data from external files or internet addresses, but we shall learn how to use their enhanced counterparts stored in the package readr which is one of the core packages of the tidyverse. In fact, these functions are much faster than their base R analogues and provide a few nice extra features. For example, if there is a non-fatal problem that occurs while reading the data, these functions return a warning and the data frame will have some information about which row/observations triggered the warning.\nUsually data are stored either in excel files or in CSV files (comma separated variable). Let’s start with the latter and suppose we want to store in R the content of the sheep data set on the course’s repository. This contains the height (in cm) and the weight (in kg) of a sample of sheep. To do so, providing the tidyverse is loaded, it suffices to run the command\n\nsheep &lt;- read_csv(\"https://raw.githubusercontent.com/acarpignani/R4DS/main/datasets/sheep.csv\")\n\nRows: 100 Columns: 2\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\ndbl (2): weight, height\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nsheep\n\n# A tibble: 100 × 2\n   weight height\n    &lt;dbl&gt;  &lt;dbl&gt;\n 1   75.2   56.3\n 2  102.    83.6\n 3   74.5   56.6\n 4   81.4   55.6\n 5   83.2   73.6\n 6   80.8   56.2\n 7   81.7   65.9\n 8   90.8   70.4\n 9  103.    66.3\n10  105.    74.0\n# ℹ 90 more rows\n\n\nWhat is the average weight and height of these sheep? We have now all the elements to respond. For example, we can call the function summary(). As we have seen this is an adaptable function and when we pass a tibble to it, it returns a summary of every variable in the tibble, like so:\n\nsummary(sheep)\n\n     weight           height     \n Min.   : 55.90   Min.   :40.57  \n 1st Qu.: 73.02   1st Qu.:57.53  \n Median : 81.78   Median :65.31  \n Mean   : 82.75   Mean   :65.02  \n 3rd Qu.: 91.02   3rd Qu.:72.19  \n Max.   :119.50   Max.   :90.05  \n\n\nLet’s load another data set, from our repository. This time we are interested in the data set containing information about the density of worms in some fields, also available in the course’s repository. Let’s call this data frame worms.\n\nworms &lt;- read_csv(\"https://raw.githubusercontent.com/acarpignani/R4DS/main/datasets/worms.csv\")\n\nRows: 20 Columns: 7\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (2): Field.Name, Vegetation\ndbl (4): Area, Slope, Soil.pH, Worm.density\nlgl (1): Damp\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nworms\n\n# A tibble: 20 × 7\n   Field.Name         Area Slope Vegetation Soil.pH Damp  Worm.density\n   &lt;chr&gt;             &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;        &lt;dbl&gt; &lt;lgl&gt;        &lt;dbl&gt;\n 1 Nashs.Field         3.6    11 Grassland      4.1 FALSE            4\n 2 Silwood.Bottom      5.1     2 Arable         5.2 FALSE            7\n 3 Nursery.Field       2.8     3 Grassland      4.3 FALSE            2\n 4 Rush.Meadow         2.4     5 Meadow         4.9 TRUE             5\n 5 Gunness.Thicket     3.8     0 Scrub          4.2 FALSE            6\n 6 Oak.Mead            3.1     2 Grassland      3.9 FALSE            2\n 7 Church.Field        3.5     3 Grassland      4.2 FALSE            3\n 8 Ashurst             2.1     0 Arable         4.8 FALSE            4\n 9 The.Orchard         1.9     0 Orchard        5.7 FALSE            9\n10 Rookery.Slope       1.5     4 Grassland      5   TRUE             7\n11 Garden.Wood         2.9    10 Scrub          5.2 FALSE            8\n12 North.Gravel        3.3     1 Grassland      4.1 FALSE            1\n13 South.Gravel        3.7     2 Grassland      4   FALSE            2\n14 Observatory.Ridge   1.8     6 Grassland      3.8 FALSE            0\n15 Pond.Field          4.1     0 Meadow         5   TRUE             6\n16 Water.Meadow        3.9     0 Meadow         4.9 TRUE             8\n17 Cheapside           2.2     8 Scrub          4.7 TRUE             4\n18 Pound.Hill          4.4     2 Arable         4.5 FALSE            5\n19 Gravel.Pit          2.9     1 Grassland      3.5 FALSE            1\n20 Farm.Wood           0.8    10 Scrub          5.1 TRUE             3\n\n\nLet’s try now to apply the summary() to this data set.\n\nsummary(worms)\n\n  Field.Name             Area           Slope        Vegetation       \n Length:20          Min.   :0.800   Min.   : 0.00   Length:20         \n Class :character   1st Qu.:2.175   1st Qu.: 0.75   Class :character  \n Mode  :character   Median :3.000   Median : 2.00   Mode  :character  \n                    Mean   :2.990   Mean   : 3.50                     \n                    3rd Qu.:3.725   3rd Qu.: 5.25                     \n                    Max.   :5.100   Max.   :11.00                     \n    Soil.pH         Damp          Worm.density \n Min.   :3.500   Mode :logical   Min.   :0.00  \n 1st Qu.:4.100   FALSE:14        1st Qu.:2.00  \n Median :4.600   TRUE :6         Median :4.00  \n Mean   :4.555                   Mean   :4.35  \n 3rd Qu.:5.000                   3rd Qu.:6.25  \n Max.   :5.700                   Max.   :9.00  \n\n\nThe variable Vegetation is another factor, so let’s transform it into a factor using again the mutate() function.\n\nworms &lt;- mutate(worms, Vegetation = factor(Vegetation))\nsummary(worms)\n\n  Field.Name             Area           Slope           Vegetation\n Length:20          Min.   :0.800   Min.   : 0.00   Arable   :3   \n Class :character   1st Qu.:2.175   1st Qu.: 0.75   Grassland:9   \n Mode  :character   Median :3.000   Median : 2.00   Meadow   :3   \n                    Mean   :2.990   Mean   : 3.50   Orchard  :1   \n                    3rd Qu.:3.725   3rd Qu.: 5.25   Scrub    :4   \n                    Max.   :5.100   Max.   :11.00                 \n    Soil.pH         Damp          Worm.density \n Min.   :3.500   Mode :logical   Min.   :0.00  \n 1st Qu.:4.100   FALSE:14        1st Qu.:2.00  \n Median :4.600   TRUE :6         Median :4.00  \n Mean   :4.555                   Mean   :4.35  \n 3rd Qu.:5.000                   3rd Qu.:6.25  \n Max.   :5.700                   Max.   :9.00  \n\n\nOnce read_csv() is clear, using readr’s other functions is straightforward. The syntax is the same, and it is only a matter of understanding which function is good for what.\n\nread_csv2() reads semicolon-separated files. These use ; instead of , to separate fields and are common in countries that use , as the decimal marker (e.g. Italy).\nread_tsv() reads tab-delimited files.\nread_delim() reads a file with any delimiter, attempting to automatically guess the delimiter, unless it is specified using the parameter delim =.\nread_table() read a common variation fixed-with files where columns are separated by white space.\n\n\n\n\nIf a data set is loaded in R in the format of a data frame, or a tibble, we might want to save it into the hard drive, in order to access it later, or to share it with others. R provides built-in functions to do so, but again readr gives an enhanced version of the same functions, which is highly recommended. Imagine we want to save the iris data set as a CSV file with the name iris.csv. To do so, we can type the following:\n\nwrite_csv(iris, file = \"./data/iris.csv\")",
    "crumbs": [
      "R programming",
      "Introduction to R programming",
      "Getting data in and out of R"
    ]
  },
  {
    "objectID": "tidyr.html",
    "href": "tidyr.html",
    "title": "Data tidying",
    "section": "",
    "text": "Data tidying",
    "crumbs": [
      "R programming",
      "Data Manipulation",
      "Data tidying"
    ]
  },
  {
    "objectID": "themes.html",
    "href": "themes.html",
    "title": "Advanced ggplot features: themes",
    "section": "",
    "text": "Advanced ggplot features: themes",
    "crumbs": [
      "R programming",
      "Data Visualisation",
      "Advanced *ggplot* features: themes"
    ]
  },
  {
    "objectID": "functions.html",
    "href": "functions.html",
    "title": "Functions with R",
    "section": "",
    "text": "Quoting Professor Roger Peng, “writing functions is a core activity of an R programmer. It represents the key step of the transition from the mere”user” to a developer who creates new functionality for R”. Functions are often used to encapsulate a chunk of code that needs to be executed numerous times, perhaps under slightly different conditions, or depending on certain parameters that serve as input to the function.\nFunctions in R are “first class objects”, which means that they can be treated pretty much like any other R object (e.g. a vector or a list). Most importantly, functions can be passed as arguments to other functions, and can be nested, so that we can define a function inside another function.\nThe syntax for a function is the following:\n\nfunction_name &lt;- function(arg1, arg2, ...) {\n    ## Code that is executed when\n    ## the function is called\n}\n\nThere are many functions already built-in in R, and loading packages we can get even more functions. If we wish to recall the structure of the function that we are about to use we can either call the help() function, or we can just call the function str() which shows the parameters and the default values of a function. For example, for the function sum(), we have\n\nstr(matrix)\n\nfunction (data = NA, nrow = 1, ncol = 1, byrow = FALSE, dimnames = NULL)  \n\n\n\n\nLet’s immediately see an example of function:\n\nhello_world &lt;- function() {\n    print(\"Hello, world!\")\n}\n\nhello_world\n\nfunction() {\n    print(\"Hello, world!\")\n}\n\n\nLet’s make this function a bit more interesting, by adding a parameter.\n\nhello &lt;- function(name) {\n    print(paste(\"Hello,\", name))\n}\n\nhello(\"Jack\")\n\n[1] \"Hello, Jack\"\n\n\nThis function is better, but if we call hello() it would throw an error, because R doesn’t know what to do with the parameter that has not been used. If we wish, we can set up a default value for the parameter, to be used unless a different value is passed to the function. For example,\n\nhello &lt;- function(name = \"world!\") {\n    print(paste(\"Hello,\", name))\n}\n\nhello()\n\n[1] \"Hello, world!\"\n\nhello(\"Mr President!\")\n\n[1] \"Hello, Mr President!\"\n\n\n\n\n\nThe function that we have created thus far only print the result. Sometimes, however, we may want to return the value, so that we can store it into a variable. This is done using the function return(). For example, assume we want to create a function that takes a name and a title and returns the name with the title in front of it. So, if we pass the name \"John Smith\" and the title \"sir\", the functions should return \"sir John Smith\". This can be done with the following code:\n\nformal &lt;- function(name = \"John Doe\", title = \"Mr\") {\n    return(paste(title, name))\n}\n\nformal()\n\n[1] \"Mr John Doe\"\n\nformal(\"Isaac Newton\", \"sir\")\n\n[1] \"sir Isaac Newton\"\n\n\nSo far, the function works in the exact same way as before, but now we can also assign the result of the value to a variable. For example,\n\nvar &lt;- formal(\"Byron\", \"Lord\")\nvar\n\n[1] \"Lord Byron\"\n\n\nAs a simple rule of thumb on when you should use a function, I once heard the following:\n\n\n\n\n\n\nTip\n\n\n\nIf you need to use cut-and-paste more than three times, use a function.\n\n\nI am not sure I always follow this rule of thumbs, but I should!\n\n\n\nCalling an R function with arguments can be done in a variety of ways. This may be confusing at first, but it is really handy when doing interactive work at the command line. R functions argument can be matched both positionally or by name. Positional matching just means that R assigns the first value to the first argument, the second value to the second argument, etc. So, in the following call to rnorm(),\n\nstr(rnorm)\n\nfunction (n, mean = 0, sd = 1)  \n\nset.seed(123)\nrnorm(10, 2, 1)\n\n [1] 1.4395244 1.7698225 3.5587083 2.0705084 2.1292877 3.7150650 2.4609162\n [8] 0.7349388 1.3131471 1.5543380\n\n\nthe number 10 is assigned to the n argument, 2 is assigned to the mean argument, and 1 is assigned to the sd argument, all by position matching. We could however achieve the same result with any of the following codes:\n\n# Matching by name with the same order\nset.seed(123)\nrnorm(n = 10, mean = 2, sd = 1)\n\n [1] 1.4395244 1.7698225 3.5587083 2.0705084 2.1292877 3.7150650 2.4609162\n [8] 0.7349388 1.3131471 1.5543380\n\n# Matching by name with a different order\nset.seed(123)\nrnorm(sd = 1, mean = 2, n = 10)\n\n [1] 1.4395244 1.7698225 3.5587083 2.0705084 2.1292877 3.7150650 2.4609162\n [8] 0.7349388 1.3131471 1.5543380\n\n\nNotice that by setting always the same seed before any call of the random number generators, we always get the same results.\nTo sum up, when specifying the function arguments by name, it doesn’t matter in what order the arguments are passed to the function: we will always obtain the same result. Very often we can also mix positional matching with matching by name. When an argument is matched by name, it is “taken out” of the argument list and the remaining unnamed arguments are matched in the order that they are listed in the function definition, as shown for example passing the function to str(). So, in the previous example, we would most likely use\n\nset.seed(123)\nrnorm(10, mean = 2, sd = 1)\n\n [1] 1.4395244 1.7698225 3.5587083 2.0705084 2.1292877 3.7150650 2.4609162\n [8] 0.7349388 1.3131471 1.5543380\n\n\n\n\n\n\n\n\nCaution\n\n\n\nQuoting again Professor Peng, “even though it’s legal, I don’t recommend messing around with the order of the arguments too much, since it can lead to do some confusion.\nMost of the time, named arguments are useful on the command line when you have a long argument list and you want to use the defaults for everything except for an argument near the end of the list. Named arguments are also help if you can remember the name of the argument and not its position on the argument list.”\n\n\n\n\n\nArguments to functions are evaluated lazily, which means that they are evaluated only as needed in the body of the function. For example,\n\nfoo &lt;- function(a, b){\n    a^2\n}\n\nfoo(3)\n\n[1] 9\n\n\nThis function never uses the argument b, so calling foo(3) will not throw an error because the 3 gets positionally matched to a. This behaviour may be considered good or bad. It is common to write a function that doesn’t actually use an argument and not notice it simply because R never throws an error.\nThis example shows lazy evaluation at work, but does eventually result in an error.\n\nfoo &lt;- function(a, b){\n    print(a)\n    print(b)\n}\n\nfoo(10)\n\n[1] 10\n\n\nError in foo(10): argument \"b\" is missing, with no default\n\n\nNotice that “10” is printed before the error is triggered. This is because b did not have to be evaluated until after print(a). Once the function tried to evaluate print(b) the function had to throw an error, because R cannot find a value for b.\n\n\n\nThere is a special argument in R known as the ... argument, which indicates a variable number of arguments that are usually passed to other functions. The ... argument is often used when extending another function but one doesn’t want to copy the entire argument list of the original function.\nFor example, we wish to create a function that simulates rolling a die a given number of times. This can be achieved by calling the function sample() on the vector 1:6, like so:\n\ndie_rolling &lt;- function(n = 1, ...) {\n    sample(1:6, size = n, replace = TRUE, ...)\n}\n\nLet’s have a look at the arguments of sample().\n\nstr(sample)\n\nfunction (x, size, replace = FALSE, prob = NULL)  \n\n\nThere is a special parameter prob that we can use to assign the probabilities of each element of the vector to be given, and we can pass it to sample, through the ... argument, to pass from a fair die to a biased one. Look at the difference between rolling a fair die and a biased one:\n\n# Fair die\nset.seed(111)\ndie_rolling(10)\n\n [1] 6 3 4 3 1 3 5 3 4 2\n\n# Biased die\nset.seed(111)\ndie_rolling(10, prob = c(0.5, 0.2 , 0.1, 0.1, 0.05, 0.05))\n\n [1] 2 3 1 2 1 1 1 2 1 1\n\n\n\n\n\nOne catch with ... is that any argument that appear after ... on the argument list must be named explicitly and cannot be partially matched or matched positionally. Take a look at the structure of the paste() function.\n\nstr(paste)\n\nfunction (..., sep = \" \", collapse = NULL, recycle0 = FALSE)  \n\n\nWith the paste() function, the arguments sep and collapse must be named explicitly and in full if the default values are not going to be used. For example,\n\npaste(\"a\", \"b\", sep = \":\")\n\n[1] \"a:b\"\n\n\nIf we don’t specify the sep argument, R would interpret the last argument as another of the ... arguments and only paste it after b, using the default value of sep. For example,\n\npaste(\"a\", \"b\", \":\")\n\n[1] \"a b :\"",
    "crumbs": [
      "R programming",
      "Basic R Programming",
      "Functions with R"
    ]
  },
  {
    "objectID": "loops.html",
    "href": "loops.html",
    "title": "Loops",
    "section": "",
    "text": "There are several control structures that represent loops. The most common are for and while.\n\n\nA for loop enables to iterate over an object (such as a vector) and then execute a block of code for every loop. The syntax for a for loop is the following:\n\nfor (temporary_variable in object) {\n    # Execute some code at every loop\n}\n\nLet us see some examples to see how to use a for loop.\n\n\nWe can think of looping through a vector in two different ways. The first way would be to create a temporary variable with the use of the in keyword:\n\nvec &lt;- 1:5\n\nfor (temp_var in vec) {\n    print(temp_var)\n}\n\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n\n\nThe other way would be to loop a numbered amount of times and then use the indexing to continually grab from the vector:\n\nfor (i in seq_along(vec)) {\n    print(vec[i])\n}\n\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n\n\nThe first method is more elegant, but sometimes it is more intuitive to use the second one.\n\n\n\nWe can do the same thing over a list.\n\nli &lt;- list(1:5, 10:20)\n\nfor (temp_var in li) {\n    print(temp_var)\n}\n\n[1] 1 2 3 4 5\n [1] 10 11 12 13 14 15 16 17 18 19 20\n\n\nTo use the second method, however, we must remember to use the double brackets [[ ]] to extract the object from the list.\n\nfor (i in seq_along(li)) {\n    print(li[[i]])\n}\n\n[1] 1 2 3 4 5\n [1] 10 11 12 13 14 15 16 17 18 19 20\n\n\n\n\n\nfor loops can be nested one inside the other, especially with structures like matrices, which have more than one dimensions. For example,\n\nmat &lt;- matrix(1:25, nrow = 5)\nmat\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    6   11   16   21\n[2,]    2    7   12   17   22\n[3,]    3    8   13   18   23\n[4,]    4    9   14   19   24\n[5,]    5   10   15   20   25\n\nfor (row in 1:nrow(mat)) {\n    for (col in 1:ncol(mat)) {\n        print(paste(\"The element at row:\", row, \"and col:\", col, \"is\", mat[row, col]))\n    }\n}\n\n[1] \"The element at row: 1 and col: 1 is 1\"\n[1] \"The element at row: 1 and col: 2 is 6\"\n[1] \"The element at row: 1 and col: 3 is 11\"\n[1] \"The element at row: 1 and col: 4 is 16\"\n[1] \"The element at row: 1 and col: 5 is 21\"\n[1] \"The element at row: 2 and col: 1 is 2\"\n[1] \"The element at row: 2 and col: 2 is 7\"\n[1] \"The element at row: 2 and col: 3 is 12\"\n[1] \"The element at row: 2 and col: 4 is 17\"\n[1] \"The element at row: 2 and col: 5 is 22\"\n[1] \"The element at row: 3 and col: 1 is 3\"\n[1] \"The element at row: 3 and col: 2 is 8\"\n[1] \"The element at row: 3 and col: 3 is 13\"\n[1] \"The element at row: 3 and col: 4 is 18\"\n[1] \"The element at row: 3 and col: 5 is 23\"\n[1] \"The element at row: 4 and col: 1 is 4\"\n[1] \"The element at row: 4 and col: 2 is 9\"\n[1] \"The element at row: 4 and col: 3 is 14\"\n[1] \"The element at row: 4 and col: 4 is 19\"\n[1] \"The element at row: 4 and col: 5 is 24\"\n[1] \"The element at row: 5 and col: 1 is 5\"\n[1] \"The element at row: 5 and col: 2 is 10\"\n[1] \"The element at row: 5 and col: 3 is 15\"\n[1] \"The element at row: 5 and col: 4 is 20\"\n[1] \"The element at row: 5 and col: 5 is 25\"\n\n\n\n\n\n\nIn a while loop, the condition in the while statement is evaluated and if it is true, the statement is executed and the condition is re-evaluated. The loop continues until the condition becomes false, at which point the execution resumes after the clause.\nThe syntax of the while statement is the following:\n\nwhile (condition) {\n    # Code to execute\n    # as long as the condition\n    # in the statement is true\n}\n\nThe major concern when working with a while loop is to make sure that at some point the condition becomes false, otherwise the loop will go on forever.\nLet’s see an example:\n\nset.seed(12)\nx &lt;- 0\n\nwhile (x != 6) {\n    x &lt;- sample(1:6, size = 1)\n    print(paste(\"We rolled a \", x))\n}\n\n[1] \"We rolled a  2\"\n[1] \"We rolled a  2\"\n[1] \"We rolled a  3\"\n[1] \"We rolled a  6\"\n\n\n\n\n\nIn this final example, we wish to study the Law of Large Numbers for a normal distribution. The Law of Large Numbers (LNN) states that if the number of samples grows, the sample mean approaches the mean of the population. So, if we extract a sample from a population with normal distribution with mean 0 and standard deviation 1, and we work out the mean of the sample, we would find a number that is close to 0. Furthermore, if we increase the size of the sample, this number gets closer and closer to 0.\nLet’s see what happens when we run the simulation 10, 100, 1000 and 100000 times.\n\ntotal &lt;- c(10L, 100L, 1000L, 100000L)\nmean_value &lt;- NULL\n\nfor (tot in total) {\n    set.seed(123)\n    count &lt;- 0\n    normal_sample &lt;- rnorm(tot)\n    for (x in normal_sample) {\n        count &lt;- count + x\n    }\n    mean_value &lt;- append(mean_value, count / tot)\n}\nprint(mean_value)\n\n[1] 0.0746256441 0.0904059086 0.0161278659 0.0009767488",
    "crumbs": [
      "R programming",
      "Basic R Programming",
      "Loops"
    ]
  },
  {
    "objectID": "ggplot-basics.html",
    "href": "ggplot-basics.html",
    "title": "Introduction to ggplot",
    "section": "",
    "text": "Introduction to ggplot",
    "crumbs": [
      "R programming",
      "Data Visualisation",
      "Introduction to *ggplot*"
    ]
  },
  {
    "objectID": "intro-gg.html",
    "href": "intro-gg.html",
    "title": "Introduction to the “Grammar of Graphics”",
    "section": "",
    "text": "Introduction to the “Grammar of Graphics”",
    "crumbs": [
      "R programming",
      "Data Visualisation",
      "Introduction to the \"Grammar of Graphics\""
    ]
  },
  {
    "objectID": "dplyr.html",
    "href": "dplyr.html",
    "title": "Data transformation",
    "section": "",
    "text": "Data transformation",
    "crumbs": [
      "R programming",
      "Data Manipulation",
      "Data transformation"
    ]
  },
  {
    "objectID": "conditionals.html",
    "href": "conditionals.html",
    "title": "Conditionals",
    "section": "",
    "text": "Control structures in R allow the user to control the flow of execution of a series of R expressions. In other words, control structures alter the otherwise sequential structure of the code. Control structures enable to respond to inputs or to features of the data and execute different R expressions accordingly. In R every line of code is a statement. Curly brackets, { }, are used in R to group statements together into a block (or chunk) of code, so that they are syntactically equivalent to a single statement. A control structure generally has the form\nkeyword (condition) {\n    statement\n}\nCommon used control structures are:\n\nif and else, used for testing a condition\nfor, to execute a loop a fixed number of times\nwhile, to execute a loop while (as long as) a condition is true\n\nIn this section we shall focus on the first type of these statements, which are called conditional expressions.\n\n\nThe if statement is probably the most commonly used control structure in R (as well as in any language). This structure enables to test a condition and act on it, depending on whether a statement is true or false.\nThe structure of an if clause is the following:\n\nif (condition) {\n    ## execute some code\n}\n\nThe above code does nothing if the condition condition is false. If, on the other hand, the condition condition is true, then the statement, i.e. the code inside the curly brackets { }, is executed.\nFor example, let’s say that we have two variables: hot and temp. Imagine that hot starts off as FALSE and temp represents a temperature, measured in degrees. If the temperature is greater than 70, we want to assign to hot the value TRUE. We could do this with the following code:\n\nhot &lt;- FALSE\ntemp &lt;- 60\n\nif (temp &gt; 70) {\n   hot &lt;- TRUE \n}\n\nhot\n\n[1] FALSE\n\n\nLet us now repeat the code, changing this time the temperature to 100.\n\ntemp &lt;- 100\n\nif (temp &gt; 70) {\n   hot &lt;- TRUE \n}\n\nhot\n\n[1] TRUE\n\n\n\n\n\n\n\n\nNote\n\n\n\nSomething to keep in mind when coding with control structures is that the code should always carefully formatted so that one can easily read it later. By convention, we align the closing curly brackets with the if statement it refers to. However, because we use brackets, we could be sloppy. Quoting Hadley Wickham, “good coding style is like correct punctuation: you can manage without it, but it sure makes things easier to read”.\nUsing a consistent style makes it easier for other to read the code. One important coding style that we should follow is to put spaces on either of mathematical operations apart from ^ (i.e. +, -, *, ==, &lt;, &gt;, etc) and around the assignment operator (&lt;-).\n\n# Strive for:\nz &lt;- (a + b)^2 / d\n\n# Avoid:\nz&lt;- ( a+b ) ^ 2/d\n\nDon’t put a space inside or outside brackets for regular function calls, but always put a space after a comma, just like in standard English.\n\n# Strive for:\nmean(x, na.rm = TRUE)\n\n# Avoid:\nmean(x,na.rm=TRUE)\n\n\n\n\n\n\nIf the condition inside the if statement is false, the code inside the if clause is skipped. If we wish to execute another block of code when the statement is false, we can use else clause. The structure is the following:\n\nif (condition) {\n    ## code to execute if condition is true\n} else {\n    ## code to execute if condition is false\n}\n\nNotice the alignment of the curly brackets { } and the use of the else. For example,\n\ntemp &lt;- 30\n\nif (temp &gt; 70) {\n    print(\"Hot\")\n} else {\n    print(\"Not hot\")\n}\n\n[1] \"Not hot\"\n\n\n\n\n\nIf we wish to have more options to print out, rather than just two options, we can nest if clauses using an else if clause. For examples\n\ntemp &lt;- 50\n\nif (temp &gt; 70) {\n    print(\"hot\")\n} else if (temp &gt; 30) {\n    print(\"warm\")\n} else {\n    print(\"cold\")\n}\n\n[1] \"warm\"\n\n\nLet’s change the value of temp and try again:\n\ntemp &lt;- 100\n\nif (temp &gt; 70) {\n    print(\"hot\")\n} else if (temp &gt; 30) {\n    print(\"warm\")\n} else {\n    print(\"cold\")\n}\n\n[1] \"hot\"\n\n\nNote how the code works. The first statement is true if temp &gt; 70, in which case, the code returns the text \"Hot\". If this condition is true, the code inside the if clause is execute, and the rest of the code is skipped. R will not even try the else if statement, but jump straight at the end of this chunk of code. On the other hand, if the condition in the if clause is false, then R moves to the else if statement and checks the new statement. If this statement is true, R runs the code inside the else if clause, then jumps at the end of the chunk of code. If, instead, this statement is also false, then R moves on and finds the else clause and runs this code.",
    "crumbs": [
      "R programming",
      "Basic R Programming",
      "Conditionals"
    ]
  },
  {
    "objectID": "purrr-functions.html",
    "href": "purrr-functions.html",
    "title": "The map family",
    "section": "",
    "text": "The map family",
    "crumbs": [
      "R programming",
      "Basic R Programming",
      "The *map* family"
    ]
  },
  {
    "objectID": "r-programming.html",
    "href": "r-programming.html",
    "title": "R programming bootcamp",
    "section": "",
    "text": "This is the notebook associated with the enhancement class R for Data Science at The Bedford Sixth Form.\n\n\nThe aim of this course is to give a thorough and opinionated introduction to R using the magnificent IDE RStudio, to show how the program excellently performs data analysis on different data sets, to introduce to the use of the meta-package tidyverse to perform exploratory data analysis, clean and reshape the data, and to give an introduction to machine learning algorithms using the meta-package tidymodels.\nIn the second part of the course, when the students have acquired the basic syntax of R, the course will move onto an individual project in which every participant can collect suitable data and analyse the data to answer a statistical question on a topic of their choice, and write a full reproducible report to show their findings. The project may be published on RPubs and can be included in the student’s portfolio, to show potential employers or to university their ability to use the software and to analyse data.\n\n\n\nThis course has basically no prerequisites, except the notions of mathematics and statistics from any GCSE Mathematics course. In particular, the learner is assumed to know the following statistical tools: mean, mode, median, range, interquartile range, box-and-whiskers plot, histogram, bar chart. Any other statistical instrument that might be useful will be briefly recalled during the course.\n\n\n\nThe following is a brief list of websites where you can find real world data sets to analyse.\n\nThe UC Irvine Machine Learning Repository (UCI Repository) contains lots of data sets that can be used to do machine learning.\nTidyTuesday is a project of the R community that aims to provide weekly real world data sets to tidy and analyse.\nKaggle is a great place to find little useful challenges to do. We shall see some of these challenges in our course, but you may always want to attempt one of them of your own. If there is a general consensus on a particular challenge, that could also be done as a team.\nThe World Bank contains a wealth of data that can be analysed.\n\nAlso you may wish to check the little publications that I have made on RPubs.\n\n\n\n\n\nTo install R, it suffices to follow the link to the Comprehensive R Archive Network (CRAN) repository and to install R clicking on the Download R for &lt;your-base-system&gt;.\n\nIn this course we will also assume that you have installed the RStudio IDE. This open-source, integrated desktop environment makes it possible for all R users to have a common R interface, which is greatly enhanced over the R’s basic command line interface.\n\nInstallation of RStudio is straightforward in most cases. The RStudio web site has links to the necessary files to download.",
    "crumbs": [
      "R programming",
      "Introduction to R programming",
      "Introduction"
    ]
  },
  {
    "objectID": "r-programming.html#introduction",
    "href": "r-programming.html#introduction",
    "title": "R programming bootcamp",
    "section": "",
    "text": "This is the notebook associated with the enhancement class R for Data Science at The Bedford Sixth Form.\n\n\nThe aim of this course is to give a thorough and opinionated introduction to R using the magnificent IDE RStudio, to show how the program excellently performs data analysis on different data sets, to introduce to the use of the meta-package tidyverse to perform exploratory data analysis, clean and reshape the data, and to give an introduction to machine learning algorithms using the meta-package tidymodels.\nIn the second part of the course, when the students have acquired the basic syntax of R, the course will move onto an individual project in which every participant can collect suitable data and analyse the data to answer a statistical question on a topic of their choice, and write a full reproducible report to show their findings. The project may be published on RPubs and can be included in the student’s portfolio, to show potential employers or to university their ability to use the software and to analyse data.\n\n\n\nThis course has basically no prerequisites, except the notions of mathematics and statistics from any GCSE Mathematics course. In particular, the learner is assumed to know the following statistical tools: mean, mode, median, range, interquartile range, box-and-whiskers plot, histogram, bar chart. Any other statistical instrument that might be useful will be briefly recalled during the course.\n\n\n\nThe following is a brief list of websites where you can find real world data sets to analyse.\n\nThe UC Irvine Machine Learning Repository (UCI Repository) contains lots of data sets that can be used to do machine learning.\nTidyTuesday is a project of the R community that aims to provide weekly real world data sets to tidy and analyse.\nKaggle is a great place to find little useful challenges to do. We shall see some of these challenges in our course, but you may always want to attempt one of them of your own. If there is a general consensus on a particular challenge, that could also be done as a team.\nThe World Bank contains a wealth of data that can be analysed.\n\nAlso you may wish to check the little publications that I have made on RPubs.",
    "crumbs": [
      "R programming",
      "Introduction to R programming",
      "Introduction"
    ]
  },
  {
    "objectID": "r-programming.html#how-to-install-r-and-rstudio",
    "href": "r-programming.html#how-to-install-r-and-rstudio",
    "title": "R programming bootcamp",
    "section": "",
    "text": "To install R, it suffices to follow the link to the Comprehensive R Archive Network (CRAN) repository and to install R clicking on the Download R for &lt;your-base-system&gt;.\n\nIn this course we will also assume that you have installed the RStudio IDE. This open-source, integrated desktop environment makes it possible for all R users to have a common R interface, which is greatly enhanced over the R’s basic command line interface.\n\nInstallation of RStudio is straightforward in most cases. The RStudio web site has links to the necessary files to download.",
    "crumbs": [
      "R programming",
      "Introduction to R programming",
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#welcome",
    "href": "index.html#welcome",
    "title": "R for Data Science",
    "section": "",
    "text": "This is the notebook associated with the enhancement class R for Data Science at The Bedford Sixth Form.\nIn this web page you can find all the topics that we have done (or that we are going to do) in the enhancement class, and more. Sometimes, in fact, we might run out of time or focus more on certain aspects, depending on the interests of the students. However here I shall try to keep things simple and as complete as I can. The idea is that whoever misses a lesson, or wants to delve into a specific aspect can either find the answer in this website or find a link pointing to someone much more expert and skilled than me that can answer the question."
  },
  {
    "objectID": "intro-ml.html",
    "href": "intro-ml.html",
    "title": "Introduction to Machine Learning with tidymodels",
    "section": "",
    "text": "Introduction to Machine Learning with tidymodels"
  },
  {
    "objectID": "practice.html",
    "href": "practice.html",
    "title": "Practice 1: Introduction to R programming",
    "section": "",
    "text": "Practice 1: Introduction to R programming\nThe questions below should be straightforward if you have reviewed the lectures: do not expect here anything particularly challenging yet. This should only be a review to make sure you have understood everything so far. In further practice sessions and projects we will encounter more challenging (and fun) activities.\n\nAnswer the following questions using R\n\nGenerate a vector that contains the numbers from 1 to 10, and concatenate its reversed vector (i.e. the vector with the same numbers in descending order), obtaining a vector with 20 elements.\nTip. You may wish to explore the function rev()\nGenerate a vector that contains 20 random numbers. Replace the 10 central values (i.e. the values in positions 5 to 15) with their corresponding squares. Round the final vector to three decimal places.\nCreate a vector called stock_prices with the following data points: 23, 27, 23, 21, 34. Assign names to the price data points relating to the day of the week, starting with Mon, Tue, Wed, etc. Calculate the average (mean) and the standard deviation of the stock price for the week.\nCreate a vector called over_23 consisting of logical values that correspond to the days where the stock price in Question 3 was greater than $23. Use the over_23 vector to filter out the stock_prices vector and only return the day and prices where the price was greater than $23.\nStill referring to the vector in Question 3, use a built-in function to find the day the price was the highest stock price. Also find the range of the stock price for the week.\nTip. Remember that the range is defined in maths as the difference between the maximum and the minimum values, however, the function range() does not give this result, but…\nSet the seed to 123 and generate 100 random numbers from a normal distribution with mean 10 and standard deviation 2. State the highest and the lowest number for this sequence.\nWe wish to simulate 100 trials of coin flipping with a fair coin. Outcome of the simulation should be a vector fair_outcome with 100 values. Each value should be either the logical. values TRUE and FALSE depending on whether the coin has landed head-up (= true) or tails-up (= false). Set the seed 101 and run the simulation.\nChange the previous code to adapt to a biased coin which lands head-up 2/3 of the times and tails-up only 1/3. Set again the seed to 101 to run the simulation and store the result into the vector biased_outcome.\nReferring to the previous two questions, create two new vectors, fair_count and biased_count containing the number of heads and tails in the two simulations.\nTip. You may wish to use the fact that logical values can be treated as 0’s and 1’s by R.\nRun a simulation for the length (in cm) and the width (in cm) of a table.\n\nSet the seed to 123 and create a vector length with 10 random vectors extracted from a normal distribution with mean 100 and standard deviation 5.\nSet the seed to 234 and create a vector width with 10 random vectors extracted from a normal distribution with mean 60 and standard deviation 5.\nCreate the vector area by multiplying together each entry of length with the corresponding entry of width, and calculate the mean and the standard deviation of this new vector. What is the standard deviation of area?",
    "crumbs": [
      "Practice",
      "Practice 1: Introduction to R programming"
    ]
  },
  {
    "objectID": "index.html#basic-bibliography",
    "href": "index.html#basic-bibliography",
    "title": "R for Data Science",
    "section": "Basic bibliography",
    "text": "Basic bibliography\nI have used a myriad of resources to create this enhancement class, and I am sure that I cannot quote them all in a single shot, because they are really too many. However, I will try to keep the bibliography up-to-date by adding the references to the books, videos, screen-casts etc, that I take inspiration from. If you notice that I have forgotten any, please do open an issue on github and/or submit a pull request. If you are comfortable with neither, just drop me a line, and I’ll fix it.\n\nR programming\n\nH Wickham, M Çetinkaya-Rundel, G Grolemund. R for Data Science. O’Reilly (2nd Ed)\nH Wickham. ggplot2 - Elegant Graphics for Data Analysis. Springer (2nd Ed)\nJ Verzani. Using R for Introductory Statistics. CRC Press (2nd Ed)\nM Kuhn, J Silge. Tidy Modeling with R. O’Reilly\nJ Silge, D Robinson. Text Mining with R. O’Reilly\nM Crawley. Statistics - An introduction using R. Wiley\nP Delgaard. Introductory Statistics with R. Springer (2nd Ed)\n\n\n\nMachine Learning\n\nG James, D Witten, T Hastie, R Tibshirani. An Introduction to Statistical Learning. Springer (2nd Ed)\nT Hastie, R Tibshirani, J Friedman. The Elements of Statistical Learning. Springer (2nd Ed)\n\n\n\nData sets sources\n\nTidyTuesday, a weekly data project in R from the R4DS online learning community\nUC Irving Machine Learning Repository\nKaggle"
  },
  {
    "objectID": "index.html#acknowledgments",
    "href": "index.html#acknowledgments",
    "title": "R for Data Science",
    "section": "Acknowledgments",
    "text": "Acknowledgments\nI have always been interested in data science, and working with R has massively enhanced this interest, by offering a magnificent tool, easy to learn, robust and beautifully open source. However, if my interest for data science with R has exploded, it is mostly thanks to the admirable work of Hadley Wickham, who has created the beautiful ggplot package and then the magnificent tidyverse. His work, his passion and his knowledge are absolutely inspiring.\nThe other person to whom I owe a wealth of knowledge is Julia Silge whose weekly screen casts has taught me not only how to use the superb tidymodels meta-package, but also what it looks like to be excellent at reshaping data sets, and at performing exploratory data analysis. Julia is constant source of inspiration for me, and if I have decided to start this project to teach “R for Data Science” at The Bedford Sixth Form, and if I have started writing the notebook for the course is thank to the wealth of knowledge that I have learnt from Julia."
  },
  {
    "objectID": "in-and-out.html#getting-data-in-r",
    "href": "in-and-out.html#getting-data-in-r",
    "title": "Getting data in and out of R",
    "section": "",
    "text": "There are useful base R functions to read data from external files or internet addresses, but we shall learn how to use their enhanced counterparts stored in the package readr which is one of the core packages of the tidyverse. In fact, these functions are much faster than their base R analogues and provide a few nice extra features. For example, if there is a non-fatal problem that occurs while reading the data, these functions return a warning and the data frame will have some information about which row/observations triggered the warning.\nUsually data are stored either in excel files or in CSV files (comma separated variable). Let’s start with the latter and suppose we want to store in R the content of the sheep data set on the course’s repository. This contains the height (in cm) and the weight (in kg) of a sample of sheep. To do so, providing the tidyverse is loaded, it suffices to run the command\n\nsheep &lt;- read_csv(\"https://raw.githubusercontent.com/acarpignani/R4DS/main/datasets/sheep.csv\")\n\nRows: 100 Columns: 2\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\ndbl (2): weight, height\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nsheep\n\n# A tibble: 100 × 2\n   weight height\n    &lt;dbl&gt;  &lt;dbl&gt;\n 1   75.2   56.3\n 2  102.    83.6\n 3   74.5   56.6\n 4   81.4   55.6\n 5   83.2   73.6\n 6   80.8   56.2\n 7   81.7   65.9\n 8   90.8   70.4\n 9  103.    66.3\n10  105.    74.0\n# ℹ 90 more rows\n\n\nWhat is the average weight and height of these sheep? We have now all the elements to respond. For example, we can call the function summary(). As we have seen this is an adaptable function and when we pass a tibble to it, it returns a summary of every variable in the tibble, like so:\n\nsummary(sheep)\n\n     weight           height     \n Min.   : 55.90   Min.   :40.57  \n 1st Qu.: 73.02   1st Qu.:57.53  \n Median : 81.78   Median :65.31  \n Mean   : 82.75   Mean   :65.02  \n 3rd Qu.: 91.02   3rd Qu.:72.19  \n Max.   :119.50   Max.   :90.05  \n\n\nLet’s load another data set, from our repository. This time we are interested in the data set containing information about the density of worms in some fields, also available in the course’s repository. Let’s call this data frame worms.\n\nworms &lt;- read_csv(\"https://raw.githubusercontent.com/acarpignani/R4DS/main/datasets/worms.csv\")\n\nRows: 20 Columns: 7\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (2): Field.Name, Vegetation\ndbl (4): Area, Slope, Soil.pH, Worm.density\nlgl (1): Damp\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nworms\n\n# A tibble: 20 × 7\n   Field.Name         Area Slope Vegetation Soil.pH Damp  Worm.density\n   &lt;chr&gt;             &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;        &lt;dbl&gt; &lt;lgl&gt;        &lt;dbl&gt;\n 1 Nashs.Field         3.6    11 Grassland      4.1 FALSE            4\n 2 Silwood.Bottom      5.1     2 Arable         5.2 FALSE            7\n 3 Nursery.Field       2.8     3 Grassland      4.3 FALSE            2\n 4 Rush.Meadow         2.4     5 Meadow         4.9 TRUE             5\n 5 Gunness.Thicket     3.8     0 Scrub          4.2 FALSE            6\n 6 Oak.Mead            3.1     2 Grassland      3.9 FALSE            2\n 7 Church.Field        3.5     3 Grassland      4.2 FALSE            3\n 8 Ashurst             2.1     0 Arable         4.8 FALSE            4\n 9 The.Orchard         1.9     0 Orchard        5.7 FALSE            9\n10 Rookery.Slope       1.5     4 Grassland      5   TRUE             7\n11 Garden.Wood         2.9    10 Scrub          5.2 FALSE            8\n12 North.Gravel        3.3     1 Grassland      4.1 FALSE            1\n13 South.Gravel        3.7     2 Grassland      4   FALSE            2\n14 Observatory.Ridge   1.8     6 Grassland      3.8 FALSE            0\n15 Pond.Field          4.1     0 Meadow         5   TRUE             6\n16 Water.Meadow        3.9     0 Meadow         4.9 TRUE             8\n17 Cheapside           2.2     8 Scrub          4.7 TRUE             4\n18 Pound.Hill          4.4     2 Arable         4.5 FALSE            5\n19 Gravel.Pit          2.9     1 Grassland      3.5 FALSE            1\n20 Farm.Wood           0.8    10 Scrub          5.1 TRUE             3\n\n\nLet’s try now to apply the summary() to this data set.\n\nsummary(worms)\n\n  Field.Name             Area           Slope        Vegetation       \n Length:20          Min.   :0.800   Min.   : 0.00   Length:20         \n Class :character   1st Qu.:2.175   1st Qu.: 0.75   Class :character  \n Mode  :character   Median :3.000   Median : 2.00   Mode  :character  \n                    Mean   :2.990   Mean   : 3.50                     \n                    3rd Qu.:3.725   3rd Qu.: 5.25                     \n                    Max.   :5.100   Max.   :11.00                     \n    Soil.pH         Damp          Worm.density \n Min.   :3.500   Mode :logical   Min.   :0.00  \n 1st Qu.:4.100   FALSE:14        1st Qu.:2.00  \n Median :4.600   TRUE :6         Median :4.00  \n Mean   :4.555                   Mean   :4.35  \n 3rd Qu.:5.000                   3rd Qu.:6.25  \n Max.   :5.700                   Max.   :9.00  \n\n\nThe variable Vegetation is another factor, so let’s transform it into a factor using again the mutate() function.\n\nworms &lt;- mutate(worms, Vegetation = factor(Vegetation))\nsummary(worms)\n\n  Field.Name             Area           Slope           Vegetation\n Length:20          Min.   :0.800   Min.   : 0.00   Arable   :3   \n Class :character   1st Qu.:2.175   1st Qu.: 0.75   Grassland:9   \n Mode  :character   Median :3.000   Median : 2.00   Meadow   :3   \n                    Mean   :2.990   Mean   : 3.50   Orchard  :1   \n                    3rd Qu.:3.725   3rd Qu.: 5.25   Scrub    :4   \n                    Max.   :5.100   Max.   :11.00                 \n    Soil.pH         Damp          Worm.density \n Min.   :3.500   Mode :logical   Min.   :0.00  \n 1st Qu.:4.100   FALSE:14        1st Qu.:2.00  \n Median :4.600   TRUE :6         Median :4.00  \n Mean   :4.555                   Mean   :4.35  \n 3rd Qu.:5.000                   3rd Qu.:6.25  \n Max.   :5.700                   Max.   :9.00  \n\n\nOnce read_csv() is clear, using readr’s other functions is straightforward. The syntax is the same, and it is only a matter of understanding which function is good for what.\n\nread_csv2() reads semicolon-separated files. These use ; instead of , to separate fields and are common in countries that use , as the decimal marker (e.g. Italy).\nread_tsv() reads tab-delimited files.\nread_delim() reads a file with any delimiter, attempting to automatically guess the delimiter, unless it is specified using the parameter delim =.\nread_table() read a common variation fixed-with files where columns are separated by white space.",
    "crumbs": [
      "R programming",
      "Introduction to R programming",
      "Getting data in and out of R"
    ]
  },
  {
    "objectID": "in-and-out.html#working-with-files-and-directories",
    "href": "in-and-out.html#working-with-files-and-directories",
    "title": "Getting data in and out of R",
    "section": "",
    "text": "Before we can describe how to import and export data in R, it becomes necessary to discuss a bit more in detail about R workflow. Let’s just start by describing good practice. When working at a project in R, using RStudio, it is convenient to always start a new Project, by clicking File &gt; New Project. Once the project is created we can create scripts to store in the directory where the Project is located, and this is set by RStudio as the working directory.\nTo see the working directory we can type\n\ngetwd()\n\nIf we wish to change the working directory, we can now type:\n\nsetwd(\"relative_path\")\n\nQuoting H wickham, once we are inside a project, we should only ever use relative paths, not absolute paths. A relative path, in fact, is relative to the working directory, i.e. the project home. This guarantees that, if two people share a project (e.g. by cloning a github repository), they both can run the code regardless of the actual location where that repository is cloned.",
    "crumbs": [
      "R programming",
      "Basics",
      "Getting data in and out of R"
    ]
  },
  {
    "objectID": "in-and-out.html#getting-data-out-of-r",
    "href": "in-and-out.html#getting-data-out-of-r",
    "title": "Getting data in and out of R",
    "section": "",
    "text": "If a data set is loaded in R in the format of a data frame, or a tibble, we might want to save it into the hard drive, in order to access it later, or to share it with others. R provides built-in functions to do so, but again readr gives an enhanced version of the same functions, which is highly recommended. Imagine we want to save the iris data set as a CSV file with the name iris.csv. To do so, we can type the following:\n\nwrite_csv(iris, file = \"./data/iris.csv\")",
    "crumbs": [
      "R programming",
      "Introduction to R programming",
      "Getting data in and out of R"
    ]
  },
  {
    "objectID": "in-and-out.html#working-directory-and-r-projects",
    "href": "in-and-out.html#working-directory-and-r-projects",
    "title": "Getting data in and out of R",
    "section": "",
    "text": "Before we can describe how to import and export data in R, it becomes necessary to discuss a bit more in detail about R workflow. Let’s just start by describing good practice. When working at a project in R, using RStudio, it is convenient to always start a new Project, by clicking File &gt; New Project.\nOnce the project is created we can create scripts to store in the directory where the Project is located, and this is set by RStudio as the working directory where R is going to start from when it reads or writes files.\nTo see the working directory we can type\n\ngetwd()\n\nIf we wish to change the working directory manually (operation that we do not recommend) we can now type:\n\nsetwd(\"relative_path\")\n\nQuoting H wickham, once we are inside a project, we should only ever use relative paths, not absolute paths. A relative path, in fact, is relative to the working directory, i.e. the project home. This guarantees that, if two people share a project (e.g. by cloning a github repository), they both can run the code regardless of the actual location where that repository is cloned.",
    "crumbs": [
      "R programming",
      "Introduction to R programming",
      "Getting data in and out of R"
    ]
  },
  {
    "objectID": "practice-basics.html",
    "href": "practice-basics.html",
    "title": "Practice 1: Introduction to R programming",
    "section": "",
    "text": "Practice 1: Introduction to R programming\nThe questions below should be straightforward if you have reviewed the lectures: do not expect here anything particularly challenging yet. This should only be a review to make sure you have understood everything so far. In further practice sessions and projects we will encounter more challenging (and fun) activities.\n\nAnswer the following questions using R\n\nGenerate a vector that contains the numbers from 1 to 10, and concatenate its reversed vector (i.e. the vector with the same numbers in descending order), obtaining a vector with 20 elements.\nTip. You may wish to check the documentation of the function sort().\nSet the seed to 101 and generate a vector that contains 20 random numbers between 0 and 1 using the function runif(). Replace the 10 central values (i.e. the values in positions 5 to 15) with their corresponding squares. Round the final vector to three decimal places.\nCreate a vector called stock_prices with the following data points: 23, 27, 23, 21, 34. Assign names to the price data points relating to the day of the week, starting with Mon, Tue, Wed, etc. Calculate the average (mean) and the standard deviation of the stock price for the week.\nCreate a vector called over_23 consisting of logical values that correspond to the days where the stock price in Question 3 was greater than $23. Use the over_23 vector to filter out the stock_prices vector and only return the day and prices where the price was greater than $23.\nStill referring to the vector in Question 3, use a built-in function to find the day the price was the highest stock price. Also find the range of the stock price for the week.\nTip. Remember that the range is defined in maths as the difference between the maximum and the minimum values, however, the function range() does not give this result, but…\nSet the seed to 123 and generate 100 random numbers from a normal distribution with mean 10 and standard deviation 2. State the highest and the lowest number for this sequence.\nWe wish to simulate 100 trials of coin flipping with a fair coin. Outcome of the simulation should be a vector fair_outcome with 100 values. Each value should be one of the two logical values TRUE and FALSE, depending on whether the coin has landed head-up (= true) or tails-up (= false). Set the seed 101 and run the simulation.\nChange the previous code to adapt to a biased coin which lands head-up 2/3 of the times and tails-up only 1/3. Set again the seed to 101 to run the simulation and store the result into the vector biased_outcome.\nReferring to the previous two questions, create two new vectors, fair_count and biased_count containing the number of heads and tails in the two simulations.\nTip. You may wish to use the fact that logical values can be treated as 0’s and 1’s by R.\nRun a simulation for the length (in cm) and the width (in cm) of a table.\n\nSet the seed to 123 and create a vector length with 10 random vectors extracted from a normal distribution with mean 100 and standard deviation 5.\nSet the seed to 234 and create a vector width with 10 random vectors extracted from a normal distribution with mean 60 and standard deviation 5.\nCreate the vector area by multiplying together each entry of length with the corresponding entry of width, and calculate the mean and the standard deviation of this new vector. What is the standard deviation of area?",
    "crumbs": [
      "Practice",
      "Practice 1: Introduction to R programming"
    ]
  },
  {
    "objectID": "practice.html#answer-the-following-questions-using-r",
    "href": "practice.html#answer-the-following-questions-using-r",
    "title": "Practice 1: Introduction to R programming",
    "section": "",
    "text": "Generate a vector that contains the numbers from 1 to 10, and concatenate its reversed vector (i.e. the vector with the same numbers in descending order), obtaining a vector with 20 elements.\nTip. You may wish to explore the function rev()\nGenerate a vector that contains 20 random numbers. Replace the 10 central values (i.e. the values 5 to 15) with their corresponding squares.\nCreate a vector called stock_prices with the following data points: 23, 27, 23, 21, 34. Assign names to the price data points relating to the day of the week, starting with Mon, Tue, Wed, etc. Calculate the average (mean) and the standard deviation of the stock price for the week.\nCreate a vector called over_23 consisting of logical values that correspond to the days where the stock price in Question 3 was greater than $23. Use the over_23 vector to filter out the stock_prices vector and only return the day and prices where the price was greater than $23.\nStill referring to the vector in Question 3, use a built-in function to find the day the price was the highest stock price.\nSet the seed to 123 and generate 100 random numbers from a normal distribution with mean 10 and standard deviation 2. State the highest and the lowest number for this sequence.\nWe wish to simulate 100 trials of coin flipping with a fair coin. Outcome of the simulation should be a vector fair_outcome with 100 values. Each value should be either the logical. values TRUE and FALSE depending on whether the coin has landed head-up (= true) or tails-up (= false). Set the seed 101 and run the simulation.\nChange the previous code to adapt to a biased coin which lands head-up 2/3 of the times and tails-up only 1/3. Set again the seed to 101 to run the simulation and store the result into the vector biased_outcome.\nReferring to the previous two questions, create two new vectors, fair_count and biased_count containing the number of heads and tails in the two simulations.\nTip. You may wish to use the fact that logical values can be treated as 0’s and 1’s by R.\nRun a simulation for the length (in cm) and the width (in cm) of a table.\n\nSet the seed to 123 and create a vector length with 10 random vectors extracted from a normal distribution with mean 100 and standard deviation 5.\nSet the seed to 234 and create a vector width with 10 random vectors extracted from a normal distribution with mean 60 and standard deviation 5.\nCreate the vector area by multiplying together each entry of length with the corresponding entry of width, and calculate the mean and the standard deviation of this new vector. What is the standard deviation of area?",
    "crumbs": [
      "Practice",
      "Practice 1: Introduction to R programming"
    ]
  },
  {
    "objectID": "matrices.html#creating-a-matrix",
    "href": "matrices.html#creating-a-matrix",
    "title": "Matrices",
    "section": "",
    "text": "To create an empty m by n matrix we can type matrix(nrow = m, ncol = n). This will generate a matrix of NA, like so:\n\nmatrix(nrow = 3, ncol = 5)\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]   NA   NA   NA   NA   NA\n[2,]   NA   NA   NA   NA   NA\n[3,]   NA   NA   NA   NA   NA\n\n\nIf we wish to create and populate a matrix at the same time, we can pass a vector with all the entries of the matrix. For example,\n\nmatrix(1:15, nrow = 3)\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    4    7   10   13\n[2,]    2    5    8   11   14\n[3,]    3    6    9   12   15\n\n\nIn this case, we don’t need to state both nrow and ncol because the total number of elements in the vector 1:15 gives this information. Notice that, by default, R populates the matrix “by column”, i.e. it fills in the first column, then it passes to the second, and so on. Sometimes, however, it is convenient to populate the matrix “by row” instead. To this end, it suffices to pass a further argument byrow = TRUE, like so:\n\nmatrix(1:15, nrow = 3, byrow = TRUE)\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    2    3    4    5\n[2,]    6    7    8    9   10\n[3,]   11   12   13   14   15\n\n\n\n\nWe can also store the rows (or the columns) of a matrix in different vectors and later combine them into a single matrix. For example, consider the following vectors below of stock prices for Google and Microsoft:\n\ngoog &lt;- c(450, 451, 452, 445, 468)\nmsft &lt;- c(230, 231, 232, 236, 228)\n\nstocks &lt;- c(goog, msft)\nstock_matrix &lt;- matrix(stocks, nrow = 2, byrow = TRUE)\nstock_matrix\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]  450  451  452  445  468\n[2,]  230  231  232  236  228\n\n\n\n\n\nNow that we have our matrix, it would be nice to name the rows and columns for reference. We can do this similarly to the names() function for vectors, but in this case we define colnames() and rownames(). Let’s apply these commands to the stock matrix we have defined before:\n\ndays &lt;- c(\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\")\nstock_names &lt;- c(\"GOOG\", \"MSFT\")\ncolnames(stock_matrix) &lt;- days\nrownames(stock_matrix) &lt;- stock_names\n\nstock_matrix\n\n     Mon Tue Wed Thu Fri\nGOOG 450 451 452 445 468\nMSFT 230 231 232 236 228\n\n\n\n\n\n\n\n\nImportant\n\n\n\nOne of the main features (and limitations) of matrices is that all values in a matrix must be of the same type. So, for example, one can create a matrix of double numbers, or a matrix of logical values, but we cannot take a matrix where one column has numbers and another has logical values. To do this, we need to use a data frame which is more general type of matrix, where the columns (but not the row) can have different types.",
    "crumbs": [
      "R programming",
      "Introduction to R programming",
      "Matrices"
    ]
  },
  {
    "objectID": "matrices.html#arithmetic-with-matrices",
    "href": "matrices.html#arithmetic-with-matrices",
    "title": "Matrices",
    "section": "",
    "text": "Let’s start by a very simple one: the comparison.\n\n\nThe comparison with matrices works exactly like the comparison with vectors. For example,\n\nmat &lt;- matrix(1:50, nrow = 5, byrow = TRUE)\n\nmat &gt; 23\n\n      [,1]  [,2]  [,3]  [,4]  [,5]  [,6]  [,7]  [,8]  [,9] [,10]\n[1,] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[2,] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[3,] FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[4,]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[5,]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n\n\n\n\n\nWe can perform element by element mathematical operations on a matrix with a scalar (single number) just like we could with vectors. Let’s see some examples of that.\n\nmat_1 &lt;- matrix(1:24, nrow = 4, byrow = TRUE)\nmat_2 &lt;- matrix(1, nrow = 4, ncol = 6)\n\nmat_1\n\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]    1    2    3    4    5    6\n[2,]    7    8    9   10   11   12\n[3,]   13   14   15   16   17   18\n[4,]   19   20   21   22   23   24\n\nmat_2\n\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]    1    1    1    1    1    1\n[2,]    1    1    1    1    1    1\n[3,]    1    1    1    1    1    1\n[4,]    1    1    1    1    1    1\n\n\nAddition\n\nmat_1 + mat_2\n\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]    2    3    4    5    6    7\n[2,]    8    9   10   11   12   13\n[3,]   14   15   16   17   18   19\n[4,]   20   21   22   23   24   25\n\n\nSubtraction\n\nmat_1 - mat_2\n\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]    0    1    2    3    4    5\n[2,]    6    7    8    9   10   11\n[3,]   12   13   14   15   16   17\n[4,]   18   19   20   21   22   23\n\n\nMultiplication by a scalar\n\n2 * mat_1\n\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]    2    4    6    8   10   12\n[2,]   14   16   18   20   22   24\n[3,]   26   28   30   32   34   36\n[4,]   38   40   42   44   46   48\n\n\nDivision by a scalar\n\n1 / mat_1\n\n           [,1]       [,2]       [,3]       [,4]       [,5]       [,6]\n[1,] 1.00000000 0.50000000 0.33333333 0.25000000 0.20000000 0.16666667\n[2,] 0.14285714 0.12500000 0.11111111 0.10000000 0.09090909 0.08333333\n[3,] 0.07692308 0.07142857 0.06666667 0.06250000 0.05882353 0.05555556\n[4,] 0.05263158 0.05000000 0.04761905 0.04545455 0.04347826 0.04166667\n\nmat_1 / 2\n\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]  0.5    1  1.5    2  2.5    3\n[2,]  3.5    4  4.5    5  5.5    6\n[3,]  6.5    7  7.5    8  8.5    9\n[4,]  9.5   10 10.5   11 11.5   12\n\n\nTo introduce the multiplication between two matrices, let’s consider another matrix:\n\nmat_2 &lt;- matrix(1:24, nrow = 4, byrow = FALSE)\nmat_2\n\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]    1    5    9   13   17   21\n[2,]    2    6   10   14   18   22\n[3,]    3    7   11   15   19   23\n[4,]    4    8   12   16   20   24\n\n\nMultiplication\n\nmat_1 * mat_2\n\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]    1   10   27   52   85  126\n[2,]   14   48   90  140  198  264\n[3,]   39   98  165  240  323  414\n[4,]   76  160  252  352  460  576\n\n\nPower\n\nmat_1 ^ 2\n\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]    1    4    9   16   25   36\n[2,]   49   64   81  100  121  144\n[3,]  169  196  225  256  289  324\n[4,]  361  400  441  484  529  576\n\n\n\n\n\n\n\n\nWarning\n\n\n\nIt is important to notice that the product and the power shown here are not the usual mathematical multiplication and power of a matrix. The mathematical operation of multiplication between matrices can be done using the operation %*% instead, as shown below.\n\n\n\nmat_1 &lt;- matrix(1:6, nrow = 2, byrow = TRUE) \nmat_2 &lt;- matrix(10:22 , nrow = 3, byrow = TRUE)\n\nWarning in matrix(10:22, nrow = 3, byrow = TRUE): data length [13] is not a\nsub-multiple or multiple of the number of rows [3]\n\nmat_1\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n\nmat_2\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]   10   11   12   13   14\n[2,]   15   16   17   18   19\n[3,]   20   21   22   10   11\n\nmat_1 %*% mat_2\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]  100  106  112   79   85\n[2,]  235  250  265  202  217",
    "crumbs": [
      "R programming",
      "Basics",
      "Matrices"
    ]
  },
  {
    "objectID": "matrices.html#matrix-operations",
    "href": "matrices.html#matrix-operations",
    "title": "Matrices",
    "section": "",
    "text": "Now that we’ve learned how to create a matrix and how to perform the basic arithmetic with matrices, let’s focus on how to use functions and perform operations on matrices.\nLet us consider again the example of the market stocks that we have seen earlier.\n\n# Prices\ngoog &lt;- c(450, 451, 452, 445, 468)\nmsft &lt;- c(230, 231, 232, 236, 228)\n\n# Put vectors into matrix\nstocks &lt;- c(goog,msft)\nstock_matrix &lt;- matrix(stocks, nrow = 2, byrow = TRUE)\n\n# Name matrix\ndays &lt;- c(\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\")\nstock_names &lt;- c(\"GOOG\", \"MSFT\")\ncolnames(stock_matrix) &lt;- days\nrownames(stock_matrix) &lt;- stock_names\n\n# Display\nstock_matrix\n\n     Mon Tue Wed Thu Fri\nGOOG 450 451 452 445 468\nMSFT 230 231 232 236 228\n\n\nWe can perform functions across the columns and rows, such as colSums() and rowSums():\n\ncolSums(stock_matrix)\n\nMon Tue Wed Thu Fri \n680 682 684 681 696 \n\nrowSums(stock_matrix)\n\nGOOG MSFT \n2266 1157 \n\n\nThese operations don’t make much sense in the context of stocks. The mean, instead, may be an interesting operation to do. Precisely,\n\nrowMeans(stock_matrix)\n\n GOOG  MSFT \n453.2 231.4 \n\n\nThere is also the corresponding column-wise mean that can be called with the command colMeans().\n\n\nLet’s go ahead and see how we can add columns and rows to a matrix, we can use the cbind() to bind a new column, and rbind() to bind a new row. For example, let’s bind a new row with Facebook stock:\n\nFB &lt;- c(111, 112, 113, 120, 145)\ntech_stocks &lt;- rbind(stock_matrix, FB)\n\nNow let’s add an average column to the matrix:\n\nstock_avg &lt;- rowMeans(tech_stocks)\nstock_avg\n\n GOOG  MSFT    FB \n453.2 231.4 120.2 \n\n\nLet’s now add the average at the end of the matrix:\n\ntech_stocks &lt;- cbind(tech_stocks, avg = stock_avg)\ntech_stocks\n\n     Mon Tue Wed Thu Fri   avg\nGOOG 450 451 452 445 468 453.2\nMSFT 230 231 232 236 228 231.4\nFB   111 112 113 120 145 120.2\n\n\nNote that we have added the new column using the syntax avg = stock_avg. If we had simply passed the vector stock_avg, the column would have been added with the name stock_avg.",
    "crumbs": [
      "R programming",
      "Basics",
      "Matrices"
    ]
  },
  {
    "objectID": "matrices.html#matrix-indexing",
    "href": "matrices.html#matrix-indexing",
    "title": "Matrices",
    "section": "",
    "text": "Just like with vectors, we use the square bracket notation to select elements from a matrix. Since we have two dimensions to work with, we will use a comma to separate our indexing for each dimension.\nSo the syntax is then:\nexample_matrix[rows, columns]\nwhere the index notation (e.g. 1:5) is put in place of the rows or columns . If either rows or columns is left blank, then we are selecting all the rows and columns.\nLet’s work through some examples:\n\nmat &lt;- matrix(1:50, nrow = 5, byrow = TRUE)\n\nLet us select the first row:\n\nmat[1,]\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nLet us now select the first column:\n\nmat[,1]\n\n[1]  1 11 21 31 41\n\n\nLet us now select the first 3 rows:\n\nmat[1:3,]\n\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n[1,]    1    2    3    4    5    6    7    8    9    10\n[2,]   11   12   13   14   15   16   17   18   19    20\n[3,]   21   22   23   24   25   26   27   28   29    30\n\n\nLet us also take the top left 2 by 3 rectangle:\n\nmat[1:2, 1:3]\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]   11   12   13\n\n\nFinally, let’s take the last two columns:\n\nmat[,9:10]\n\n     [,1] [,2]\n[1,]    9   10\n[2,]   19   20\n[3,]   29   30\n[4,]   39   40\n[5,]   49   50",
    "crumbs": [
      "R programming",
      "Introduction to R programming",
      "Matrices"
    ]
  },
  {
    "objectID": "practice-matrices.html",
    "href": "practice-matrices.html",
    "title": "Practice 2: Matrices and Lists",
    "section": "",
    "text": "Practice 2: Matrices and Lists\n\nAnswer the following questions using R\n\nCreate 2 vectors A and B, where A is (1, 2, 3) and B is (4, 5, 6). With these vectors, use the cbind() or rbind() function to create a 2 by 3 matrix from the vectors.\nTip. You will need to figure out which of these binding functions is the correct choice.\nCreate a 3 by 3 matrix consisting of the numbers 1 to 9. Create this matrix using the shortcut 1:9 and by specifying the nrow argument in the matrix() function call. Assign this matrix to the variable mat.\nConfirm that mat is a matrix using is.matrix().\nCreate a 5 by 5 matrix consisting of the numbers 1 to 25 and assign it to the variable mat2. The top row should be the numbers 1 to 5.\nUsing indexing notation, grab a sub-matrix of mat2 from question 4 that looks like this:  \\begin{pmatrix}  7 & 8 \\cr 12 & 13 \\end{pmatrix} \nUsing indexing notation, grab a sub-section of mat2 from question 4 that looks like this:  \\begin{pmatrix}  19 & 20 \\cr 24 & 25 \\end{pmatrix} \nWhat is the sum of all the elements in mat2?\nCreate a 4 \\times 5 matrix consisting of 20 random numbers extracted from a uniform distribution. Set the seed to 101 to ensure reproducibility. Take the square of this matrix, and give the final matrix rounded to two decimal places.\nSet the seed 101 to create a 5 \\times 5 matrix which contains random numbers, and calculate its determinant. Repeat the same experiment 10 times, storing the determinant of each matrix in a vector determinants with length 10 and find the mean and the standard deviation of this vector.\nTip. You may wish to use the function det() to calculate the determinant.\nSet the seed to 111 and generate a matrix \\mathbf{A} with dimension 4 \\times 6 and a vector \\mathbf{b} with length 4. Obtain a new matrix 4 \\times 7 whose first 6 columns are the columns of \\mathbf{A} and the seventh column contains the values of \\mathbf{b}.\nSet the seed to 111 and generate a matrix \\mathbf{A} with dimension 4 \\times 6 and a vector \\mathbf{b} with length 6. Obtain a new matrix 5 \\times 6 whose first 4 rows are the rows of \\mathbf{A} and the fifth row contains the values of \\mathbf{b}.\nCreate a vector vec containing the integers from 1 to 5. Using the function diag() create a 5 \\times 5 diagonal matrix which has the elements of vec on the diagonal. Find the determinant of this matrix and check that this is the same as the product of the elements in vec.\nTip. You may wish to explore the function prod().\nSet the seed to 123 and create a 5 \\times 5 matrix Q containing random numbers taken from the uniform distribution. Use the function solve() to find the inverse matrix. Show that this is, in fact, the inverse of the matrix Q using the matrix product %*%.\nTip. You may wish to compare a suitable matrix to I &lt;- diag(rep(1, times = 5)).",
    "crumbs": [
      "Practice",
      "Practice 2: Matrices and Lists"
    ]
  },
  {
    "objectID": "practice-matrices.html#answer-the-following-questions-using-r",
    "href": "practice-matrices.html#answer-the-following-questions-using-r",
    "title": "Practice 2: Matrices and lists",
    "section": "",
    "text": "Create 2 vectors A and B, where A is (1, 2, 3) and B is (4, 5, 6). With these vectors, use the cbind() or rbind() function to create a 2 by 3 matrix from the vectors.\nTip. You will need to figure out which of these binding functions is the correct choice.\nCreate a 3 by 3 matrix consisting of the numbers 1 to 9. Create this matrix using the shortcut 1:9 and by specifying the nrow argument in the matrix() function call. Assign this matrix to the variable mat.\nConfirm that mat is a matrix using is.matrix().\nCreate a 5 by 5 matrix consisting of the numbers 1 to 25 and assign it to the variable mat2. The top row should be the numbers 1 to 5.\nUsing indexing notation, grab a sub-matrix of mat2 from question 4 that looks like this:  \\begin{pmatrix}  7 & 8 \\cr 12 & 13 \\end{pmatrix} \nUsing indexing notation, grab a sub-section of mat2 from question 4 that looks like this:  \\begin{pmatrix}  19 & 20 \\cr 24 & 25 \\end{pmatrix} \nWhat is the sum of all the elements in mat2?\nCreate a 4 \\times 5 matrix consisting of 20 random numbers extracted from a uniform distribution. Set the seed to 101 to ensure reproducibility. Take the square of this matrix, and give the final matrix rounded to two decimal places.\nSet the seed 101 to create a 5 \\times 5 matrix which contains random numbers, and calculate its determinant. Repeat the same experiment 10 times, storing the determinant of each matrix in a vector determinants with length 10 and find the mean and the standard deviation of this vector.\nTip. You may wish to use the function det() to calculate the determinant.\nSet the seed to 111 and generate a matrix \\mathbf{A} with dimension 4 \\times 6 and a vector \\mathbf{b} with length 4. Obtain a new matrix 4 \\times 7 whose first 6 columns are the columns of \\mathbf{A} and the seventh column contains the values of \\mathbf{b}.\nSet the seed to 111 and generate a matrix \\mathbf{A} with dimension 4 \\times 6 and a vector \\mathbf{b} with length 6. Obtain a new matrix 5 \\times 6 whose first 4 rows are the rows of \\mathbf{A} and the fifth row contains the values of \\mathbf{b}.\nCreate a vector vec containing the integers from 1 to 5. Using the function diag() create a 5 \\times 5 diagonal matrix which has the elements of vec on the diagonal. Find the determinant of this matrix and check that this is the same as the product of the elements in vec.\nTip. You may wish to explore the function prod().\nSet the seed to 123 and create a 5 \\times 5 matrix Q containing random numbers taken from the uniform distribution. Use the function solve() to find the inverse matrix. Show that this is, in fact, the inverse of the matrix Q using the matrix product %*%.\nTip. You may wish to compare a suitable matrix to I &lt;- diag(rep(1, times = 5)).",
    "crumbs": [
      "Practice",
      "Practice 2: Matrices and lists"
    ]
  },
  {
    "objectID": "conditionals.html#if-else",
    "href": "conditionals.html#if-else",
    "title": "Conditionals",
    "section": "",
    "text": "The if and else combination is probably the most commonly used control structure in R (or virtually in any language). This structure enables to test a condition and act on it, depending on whether a statement is true or false.\nLet us start with the if statement. The structure is the following:\n\nif(condition) {\n    ## do something\n}\n\nThe above code does nothing if the condition condition is false. If, on the other hand, the condition condition is true, then the the code inside the curly brackets { } is executed.\nAs we have said, if the condition condition is false, this code does not take any action. If we wish to have an action that we wish to execute then the condition is false, we need to add the else clause. The structure is the following:\n\nif(condition) {\n    ## do something\n} else {\n    ## do something else\n}\n\nWe can also concatenate more than one if clause at the same time, like so:\n\nif(condition_1) {\n    ## do something\n} else if(condition_2) {\n    ## do something different\n} else {\n    ## do something different\n}\n\nLet’s see an example. For example, let’s generate a random number between -1 and 1, and we wish to return the statement “it is positive” if the number is positive, and “it is negative” if the number is negative. If the number is 0, we wish to state it as well. We could use the following code:\n\nset.seed(101)\nx &lt;- runif(1, min = -1, max = 1)\n\nif(x &gt; 0){\n    print(\"it is positive\")\n} else if(x &lt; 0){\n    print(\"it is negative\")\n} else {\n    print(\"it is zero\")\n}\n\n[1] \"it is negative\"\n\n\nLet’s set another seed and try again:\n\nset.seed(111)\nx &lt;- runif(1, min = -1, max = 1)\n\nif(x &gt; 0){\n    print(\"it is positive\")\n} else if(x &lt; 0){\n    print(\"it is negative\")\n} else {\n    print(\"it is zero\")\n}\n\n[1] \"it is positive\"",
    "crumbs": [
      "R programming",
      "Basic R Programming",
      "Conditionals"
    ]
  },
  {
    "objectID": "conditionals.html#if-clause",
    "href": "conditionals.html#if-clause",
    "title": "Conditionals",
    "section": "",
    "text": "The if statement is probably the most commonly used control structure in R (as well as in any language). This structure enables to test a condition and act on it, depending on whether a statement is true or false.\nThe structure of an if clause is the following:\n\nif (condition) {\n    ## execute some code\n}\n\nThe above code does nothing if the condition condition is false. If, on the other hand, the condition condition is true, then the statement, i.e. the code inside the curly brackets { }, is executed.\nFor example, let’s say that we have two variables: hot and temp. Imagine that hot starts off as FALSE and temp represents a temperature, measured in degrees. If the temperature is greater than 70, we want to assign to hot the value TRUE. We could do this with the following code:\n\nhot &lt;- FALSE\ntemp &lt;- 60\n\nif (temp &gt; 70) {\n   hot &lt;- TRUE \n}\n\nhot\n\n[1] FALSE\n\n\nLet us now repeat the code, changing this time the temperature to 100.\n\ntemp &lt;- 100\n\nif (temp &gt; 70) {\n   hot &lt;- TRUE \n}\n\nhot\n\n[1] TRUE\n\n\n\n\n\n\n\n\nNote\n\n\n\nSomething to keep in mind when coding with control structures is that the code should always carefully formatted so that one can easily read it later. By convention, we align the closing curly brackets with the if statement it refers to. However, because we use brackets, we could be sloppy. Quoting Hadley Wickham, “good coding style is like correct punctuation: you can manage without it, but it sure makes things easier to read”.\nUsing a consistent style makes it easier for other to read the code. One important coding style that we should follow is to put spaces on either of mathematical operations apart from ^ (i.e. +, -, *, ==, &lt;, &gt;, etc) and around the assignment operator (&lt;-).\n\n# Strive for:\nz &lt;- (a + b)^2 / d\n\n# Avoid:\nz&lt;- ( a+b ) ^ 2/d\n\nDon’t put a space inside or outside brackets for regular function calls, but always put a space after a comma, just like in standard English.\n\n# Strive for:\nmean(x, na.rm = TRUE)\n\n# Avoid:\nmean(x,na.rm=TRUE)",
    "crumbs": [
      "R programming",
      "Basic R Programming",
      "Conditionals"
    ]
  },
  {
    "objectID": "conditionals.html#else-clause",
    "href": "conditionals.html#else-clause",
    "title": "Conditionals",
    "section": "",
    "text": "If the condition inside the if statement is false, the code inside the if clause is skipped. If we wish to execute another block of code when the statement is false, we can use else clause. The structure is the following:\n\nif (condition) {\n    ## code to execute if condition is true\n} else {\n    ## code to execute if condition is false\n}\n\nNotice the alignment of the curly brackets { } and the use of the else. For example,\n\ntemp &lt;- 30\n\nif (temp &gt; 70) {\n    print(\"Hot\")\n} else {\n    print(\"Not hot\")\n}\n\n[1] \"Not hot\"",
    "crumbs": [
      "R programming",
      "Basic R Programming",
      "Conditionals"
    ]
  },
  {
    "objectID": "conditionals.html#else-if-clause",
    "href": "conditionals.html#else-if-clause",
    "title": "Conditionals",
    "section": "",
    "text": "If we wish to have more options to print out, rather than just two options, we can nest if clauses using an else if clause. For examples\n\ntemp &lt;- 50\n\nif (temp &gt; 70) {\n    print(\"hot\")\n} else if (temp &gt; 30) {\n    print(\"warm\")\n} else {\n    print(\"cold\")\n}\n\n[1] \"warm\"\n\n\nLet’s change the value of temp and try again:\n\ntemp &lt;- 100\n\nif (temp &gt; 70) {\n    print(\"hot\")\n} else if (temp &gt; 30) {\n    print(\"warm\")\n} else {\n    print(\"cold\")\n}\n\n[1] \"hot\"\n\n\nNote how the code works. The first statement is true if temp &gt; 70, in which case, the code returns the text \"Hot\". If this condition is true, the code inside the if clause is execute, and the rest of the code is skipped. R will not even try the else if statement, but jump straight at the end of this chunk of code. On the other hand, if the condition in the if clause is false, then R moves to the else if statement and checks the new statement. If this statement is true, R runs the code inside the else if clause, then jumps at the end of the chunk of code. If, instead, this statement is also false, then R moves on and finds the else clause and runs this code.",
    "crumbs": [
      "R programming",
      "Basic R Programming",
      "Conditionals"
    ]
  },
  {
    "objectID": "loops.html#for-loops",
    "href": "loops.html#for-loops",
    "title": "Loops",
    "section": "",
    "text": "A for loop enables to iterate over an object (such as a vector) and then execute a block of code for every loop. The syntax for a for loop is the following:\n\nfor (temporary_variable in object) {\n    # Execute some code at every loop\n}\n\nLet us see some examples to see how to use a for loop.\n\n\nWe can think of looping through a vector in two different ways. The first way would be to create a temporary variable with the use of the in keyword:\n\nvec &lt;- 1:5\n\nfor (temp_var in vec) {\n    print(temp_var)\n}\n\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n\n\nThe other way would be to loop a numbered amount of times and then use the indexing to continually grab from the vector:\n\nfor (i in seq_along(vec)) {\n    print(vec[i])\n}\n\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n\n\nThe first method is more elegant, but sometimes it is more intuitive to use the second one.\n\n\n\nWe can do the same thing over a list.\n\nli &lt;- list(1:5, 10:20)\n\nfor (temp_var in li) {\n    print(temp_var)\n}\n\n[1] 1 2 3 4 5\n [1] 10 11 12 13 14 15 16 17 18 19 20\n\n\nTo use the second method, however, we must remember to use the double brackets [[ ]] to extract the object from the list.\n\nfor (i in seq_along(li)) {\n    print(li[[i]])\n}\n\n[1] 1 2 3 4 5\n [1] 10 11 12 13 14 15 16 17 18 19 20\n\n\n\n\n\nfor loops can be nested one inside the other, especially with structures like matrices, which have more than one dimensions. For example,\n\nmat &lt;- matrix(1:25, nrow = 5)\nmat\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    6   11   16   21\n[2,]    2    7   12   17   22\n[3,]    3    8   13   18   23\n[4,]    4    9   14   19   24\n[5,]    5   10   15   20   25\n\nfor (row in 1:nrow(mat)) {\n    for (col in 1:ncol(mat)) {\n        print(paste(\"The element at row:\", row, \"and col:\", col, \"is\", mat[row, col]))\n    }\n}\n\n[1] \"The element at row: 1 and col: 1 is 1\"\n[1] \"The element at row: 1 and col: 2 is 6\"\n[1] \"The element at row: 1 and col: 3 is 11\"\n[1] \"The element at row: 1 and col: 4 is 16\"\n[1] \"The element at row: 1 and col: 5 is 21\"\n[1] \"The element at row: 2 and col: 1 is 2\"\n[1] \"The element at row: 2 and col: 2 is 7\"\n[1] \"The element at row: 2 and col: 3 is 12\"\n[1] \"The element at row: 2 and col: 4 is 17\"\n[1] \"The element at row: 2 and col: 5 is 22\"\n[1] \"The element at row: 3 and col: 1 is 3\"\n[1] \"The element at row: 3 and col: 2 is 8\"\n[1] \"The element at row: 3 and col: 3 is 13\"\n[1] \"The element at row: 3 and col: 4 is 18\"\n[1] \"The element at row: 3 and col: 5 is 23\"\n[1] \"The element at row: 4 and col: 1 is 4\"\n[1] \"The element at row: 4 and col: 2 is 9\"\n[1] \"The element at row: 4 and col: 3 is 14\"\n[1] \"The element at row: 4 and col: 4 is 19\"\n[1] \"The element at row: 4 and col: 5 is 24\"\n[1] \"The element at row: 5 and col: 1 is 5\"\n[1] \"The element at row: 5 and col: 2 is 10\"\n[1] \"The element at row: 5 and col: 3 is 15\"\n[1] \"The element at row: 5 and col: 4 is 20\"\n[1] \"The element at row: 5 and col: 5 is 25\"",
    "crumbs": [
      "R programming",
      "Basic R Programming",
      "Loops"
    ]
  },
  {
    "objectID": "loops.html#while-loops",
    "href": "loops.html#while-loops",
    "title": "Loops",
    "section": "",
    "text": "In a while loop, the condition in the while statement is evaluated and if it is true, the statement is executed and the condition is re-evaluated. The loop continues until the condition becomes false, at which point the execution resumes after the clause.\nThe syntax of the while statement is the following:\n\nwhile (condition) {\n    # Code to execute\n    # as long as the condition\n    # in the statement is true\n}\n\nThe major concern when working with a while loop is to make sure that at some point the condition becomes false, otherwise the loop will go on forever.\nLet’s see an example:\n\nset.seed(12)\nx &lt;- 0\n\nwhile (x != 6) {\n    x &lt;- sample(1:6, size = 1)\n    print(paste(\"We rolled a \", x))\n}\n\n[1] \"We rolled a  2\"\n[1] \"We rolled a  2\"\n[1] \"We rolled a  3\"\n[1] \"We rolled a  6\"",
    "crumbs": [
      "R programming",
      "Basic R Programming",
      "Loops"
    ]
  },
  {
    "objectID": "loops.html#final-example-the-law-of-large-numbers",
    "href": "loops.html#final-example-the-law-of-large-numbers",
    "title": "Loops",
    "section": "",
    "text": "In this final example, we wish to study the Law of Large Numbers for a normal distribution. The Law of Large Numbers (LNN) states that if the number of samples grows, the sample mean approaches the mean of the population. So, if we extract a sample from a population with normal distribution with mean 0 and standard deviation 1, and we work out the mean of the sample, we would find a number that is close to 0. Furthermore, if we increase the size of the sample, this number gets closer and closer to 0.\nLet’s see what happens when we run the simulation 10, 100, 1000 and 100000 times.\n\ntotal &lt;- c(10L, 100L, 1000L, 100000L)\nmean_value &lt;- NULL\n\nfor (tot in total) {\n    set.seed(123)\n    count &lt;- 0\n    normal_sample &lt;- rnorm(tot)\n    for (x in normal_sample) {\n        count &lt;- count + x\n    }\n    mean_value &lt;- append(mean_value, count / tot)\n}\nprint(mean_value)\n\n[1] 0.0746256441 0.0904059086 0.0161278659 0.0009767488",
    "crumbs": [
      "R programming",
      "Basic R Programming",
      "Loops"
    ]
  },
  {
    "objectID": "r-basics.html#comments-in-r",
    "href": "r-basics.html#comments-in-r",
    "title": "Introduction to R",
    "section": "",
    "text": "R ignores anything after a # sign in a line, whether it is at the beginning of a line or in the middle. Unless the sign # is escaped, this symbol tells R that whatever comes next is a comment, and therefore R ignores it.\nRunning code in the console generally doesn’t require comments, so comments are hardly ever used in this context. However, when a code is saved into an R script, it easily becomes messy and confusing, and that is when comments are become really helpful. Using code we can separate chunks of codes, write little notes on the work that we have done, recall results, and even sometimes copy some results into the script for future reference. It is good practice to always write comments in the code, and I would encourage everyone to always use them in their scripts.",
    "crumbs": [
      "R programming",
      "Introduction to R programming",
      "Introduction to R"
    ]
  },
  {
    "objectID": "functions.html#simple-examples-of-functions",
    "href": "functions.html#simple-examples-of-functions",
    "title": "Functions with R",
    "section": "",
    "text": "Let’s immediately see an example of function:\n\nhello_world &lt;- function() {\n    print(\"Hello, world!\")\n}\n\nhello_world\n\nfunction() {\n    print(\"Hello, world!\")\n}\n\n\nLet’s make this function a bit more interesting, by adding a parameter.\n\nhello &lt;- function(name) {\n    print(paste(\"Hello,\", name))\n}\n\nhello(\"Jack\")\n\n[1] \"Hello, Jack\"\n\n\nThis function is better, but if we call hello() it would throw an error, because R doesn’t know what to do with the parameter that has not been used. If we wish, we can set up a default value for the parameter, to be used unless a different value is passed to the function. For example,\n\nhello &lt;- function(name = \"world!\") {\n    print(paste(\"Hello,\", name))\n}\n\nhello()\n\n[1] \"Hello, world!\"\n\nhello(\"Mr President!\")\n\n[1] \"Hello, Mr President!\"",
    "crumbs": [
      "R programming",
      "Basic R Programming",
      "Functions with R"
    ]
  },
  {
    "objectID": "functions.html#returning-a-value",
    "href": "functions.html#returning-a-value",
    "title": "Functions with R",
    "section": "",
    "text": "The function that we have created thus far only print the result. Sometimes, however, we may want to return the value, so that we can store it into a variable. This is done using the function return(). For example, assume we want to create a function that takes a name and a title and returns the name with the title in front of it. So, if we pass the name \"John Smith\" and the title \"sir\", the functions should return \"sir John Smith\". This can be done with the following code:\n\nformal &lt;- function(name = \"John Doe\", title = \"Mr\") {\n    return(paste(title, name))\n}\n\nformal()\n\n[1] \"Mr John Doe\"\n\nformal(\"Isaac Newton\", \"sir\")\n\n[1] \"sir Isaac Newton\"\n\n\nSo far, the function works in the exact same way as before, but now we can also assign the result of the value to a variable. For example,\n\nvar &lt;- formal(\"Byron\", \"Lord\")\nvar\n\n[1] \"Lord Byron\"\n\n\nAs a simple rule of thumb on when you should use a function, I once heard the following:\n\n\n\n\n\n\nTip\n\n\n\nIf you need to use cut-and-paste more than three times, use a function.\n\n\nI am not sure I always follow this rule of thumbs, but I should!",
    "crumbs": [
      "R programming",
      "Basic R Programming",
      "Functions with R"
    ]
  },
  {
    "objectID": "functions.html#argument-matching",
    "href": "functions.html#argument-matching",
    "title": "Functions with R",
    "section": "",
    "text": "Calling an R function with arguments can be done in a variety of ways. This may be confusing at first, but it is really handy when doing interactive work at the command line. R functions argument can be matched both positionally or by name. Positional matching just means that R assigns the first value to the first argument, the second value to the second argument, etc. So, in the following call to rnorm(),\n\nstr(rnorm)\n\nfunction (n, mean = 0, sd = 1)  \n\nset.seed(123)\nrnorm(10, 2, 1)\n\n [1] 1.4395244 1.7698225 3.5587083 2.0705084 2.1292877 3.7150650 2.4609162\n [8] 0.7349388 1.3131471 1.5543380\n\n\nthe number 10 is assigned to the n argument, 2 is assigned to the mean argument, and 1 is assigned to the sd argument, all by position matching. We could however achieve the same result with any of the following codes:\n\n# Matching by name with the same order\nset.seed(123)\nrnorm(n = 10, mean = 2, sd = 1)\n\n [1] 1.4395244 1.7698225 3.5587083 2.0705084 2.1292877 3.7150650 2.4609162\n [8] 0.7349388 1.3131471 1.5543380\n\n# Matching by name with a different order\nset.seed(123)\nrnorm(sd = 1, mean = 2, n = 10)\n\n [1] 1.4395244 1.7698225 3.5587083 2.0705084 2.1292877 3.7150650 2.4609162\n [8] 0.7349388 1.3131471 1.5543380\n\n\nNotice that by setting always the same seed before any call of the random number generators, we always get the same results.\nTo sum up, when specifying the function arguments by name, it doesn’t matter in what order the arguments are passed to the function: we will always obtain the same result. Very often we can also mix positional matching with matching by name. When an argument is matched by name, it is “taken out” of the argument list and the remaining unnamed arguments are matched in the order that they are listed in the function definition, as shown for example passing the function to str(). So, in the previous example, we would most likely use\n\nset.seed(123)\nrnorm(10, mean = 2, sd = 1)\n\n [1] 1.4395244 1.7698225 3.5587083 2.0705084 2.1292877 3.7150650 2.4609162\n [8] 0.7349388 1.3131471 1.5543380\n\n\n\n\n\n\n\n\nCaution\n\n\n\nQuoting again Professor Peng, “even though it’s legal, I don’t recommend messing around with the order of the arguments too much, since it can lead to do some confusion.\nMost of the time, named arguments are useful on the command line when you have a long argument list and you want to use the defaults for everything except for an argument near the end of the list. Named arguments are also help if you can remember the name of the argument and not its position on the argument list.”",
    "crumbs": [
      "R programming",
      "Basic R Programming",
      "Functions with R"
    ]
  },
  {
    "objectID": "functions.html#lazy-evaluation",
    "href": "functions.html#lazy-evaluation",
    "title": "Functions with R",
    "section": "",
    "text": "Arguments to functions are evaluated lazily, which means that they are evaluated only as needed in the body of the function. For example,\n\nfoo &lt;- function(a, b){\n    a^2\n}\n\nfoo(3)\n\n[1] 9\n\n\nThis function never uses the argument b, so calling foo(3) will not throw an error because the 3 gets positionally matched to a. This behaviour may be considered good or bad. It is common to write a function that doesn’t actually use an argument and not notice it simply because R never throws an error.\nThis example shows lazy evaluation at work, but does eventually result in an error.\n\nfoo &lt;- function(a, b){\n    print(a)\n    print(b)\n}\n\nfoo(10)\n\n[1] 10\n\n\nError in foo(10): argument \"b\" is missing, with no default\n\n\nNotice that “10” is printed before the error is triggered. This is because b did not have to be evaluated until after print(a). Once the function tried to evaluate print(b) the function had to throw an error, because R cannot find a value for b.",
    "crumbs": [
      "R programming",
      "Basic R Programming",
      "Functions with R"
    ]
  },
  {
    "objectID": "functions.html#the-...-argument",
    "href": "functions.html#the-...-argument",
    "title": "Functions with R",
    "section": "",
    "text": "There is a special argument in R known as the ... argument, which indicates a variable number of arguments that are usually passed to other functions. The ... argument is often used when extending another function but one doesn’t want to copy the entire argument list of the original function.\nFor example, we wish to create a function that simulates rolling a die a given number of times. This can be achieved by calling the function sample() on the vector 1:6, like so:\n\ndie_rolling &lt;- function(n = 1, ...) {\n    sample(1:6, size = n, replace = TRUE, ...)\n}\n\nLet’s have a look at the arguments of sample().\n\nstr(sample)\n\nfunction (x, size, replace = FALSE, prob = NULL)  \n\n\nThere is a special parameter prob that we can use to assign the probabilities of each element of the vector to be given, and we can pass it to sample, through the ... argument, to pass from a fair die to a biased one. Look at the difference between rolling a fair die and a biased one:\n\n# Fair die\nset.seed(111)\ndie_rolling(10)\n\n [1] 6 3 4 3 1 3 5 3 4 2\n\n# Biased die\nset.seed(111)\ndie_rolling(10, prob = c(0.5, 0.2 , 0.1, 0.1, 0.05, 0.05))\n\n [1] 2 3 1 2 1 1 1 2 1 1",
    "crumbs": [
      "R programming",
      "Basic R Programming",
      "Functions with R"
    ]
  },
  {
    "objectID": "functions.html#arguments-coming-after-the-...-argument",
    "href": "functions.html#arguments-coming-after-the-...-argument",
    "title": "Functions with R",
    "section": "",
    "text": "One catch with ... is that any argument that appear after ... on the argument list must be named explicitly and cannot be partially matched or matched positionally. Take a look at the structure of the paste() function.\n\nstr(paste)\n\nfunction (..., sep = \" \", collapse = NULL, recycle0 = FALSE)  \n\n\nWith the paste() function, the arguments sep and collapse must be named explicitly and in full if the default values are not going to be used. For example,\n\npaste(\"a\", \"b\", sep = \":\")\n\n[1] \"a:b\"\n\n\nIf we don’t specify the sep argument, R would interpret the last argument as another of the ... arguments and only paste it after b, using the default value of sep. For example,\n\npaste(\"a\", \"b\", \":\")\n\n[1] \"a b :\"",
    "crumbs": [
      "R programming",
      "Basic R Programming",
      "Functions with R"
    ]
  },
  {
    "objectID": "practice-data-frames.html",
    "href": "practice-data-frames.html",
    "title": "Practice 3: Data Frames",
    "section": "",
    "text": "Practice 3: Data Frames",
    "crumbs": [
      "Practice",
      "Practice 3: Data Frames"
    ]
  },
  {
    "objectID": "practice-control-flow.html",
    "href": "practice-control-flow.html",
    "title": "Practice 4: Control structures",
    "section": "",
    "text": "Practice 4: Control structures",
    "crumbs": [
      "Practice",
      "Practice 4: Control structures"
    ]
  },
  {
    "objectID": "practice-functions.html",
    "href": "practice-functions.html",
    "title": "Practice 5: Functions",
    "section": "",
    "text": "Practice 5: Functions",
    "crumbs": [
      "Practice",
      "Practice 5: Functions"
    ]
  }
]