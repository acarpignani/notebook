[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R for Data Science",
    "section": "",
    "text": "Introduction\nWelcome to the public repository of the enhancement class on R for Data Science offered at The Bedford Sixth Form. In this page you will find the list of all data set that are going to be used in the course, as well as useful information, and a brief note of all the topics covered in each lesson.\n\nAim of this course\nThe aim of this course is to give a thorough and opinionated introduction to R using the magnificent IDE RStudio, to show how the program excellently performs data analysis on different data sets, to introduce to the use of the meta-package tidyverse to perform exploratory data analysis, clean and reshape the data, and to give an introduction to machine learning algorithms using the meta-package tidymodels.\nIn the second part of the course, when the students have acquired the basic syntax of R, the course will move onto an individual project in which every participant can collect suitable data and analyse the data to answer a statistical question on a topic of their choice, and write a full reproducible report to show their findings. The project may be published on RPubs and can be included in the student’s portfolio, to show potential employers or to university their ability to use the software and to analyse data.\n\n\nPrerequisites to follow this course\nThis course has basically no prerequisites, except the notions of mathematics and statistics from any GCSE Mathematics course. In particular, the learner is assumed to know the following statistical tools: mean, mode, median, range, interquartile range, box-and-whiskers plot, histogram, bar chart. Any other statistical instrument that might be useful will be briefly recalled during the course.\n\n\nInstall R and RStudio\n\nTo install R, it suffices to follow the link to the Comprehensive R Archive Network (CRAN) repository and to install R clicking on the Download R for &lt;your-base-system&gt;.\n\nIn this course we will also assume that you have installed the RStudio IDE. This open-source, integrated desktop environment makes it possible for all R users to have a common R interface, which is greatly enhanced over the R’s basic command line interface.\n\nInstallation of RStudio is straightforward in most cases. The RStudio web site has links to the necessary files to download.\n\n\n\nBibliography\nI am adding below some websites that you might find useful to look for data.\n\nThe UC Irvine Machine Learning Repository (UCI Repository) contains lots of data sets that can be used to do machine learning.\nTidyTuesday is a project of the R community that aims to provide weekly real world data sets to tidy and analyse.\nKaggle is a great place to find little useful challenges to do. We shall see some of these challenges in our course, but you may always want to attempt one of them of your own. If there is a general consensus on a particular challenge, that could also be done as a team.\nThe World Bank contains a wealth of data that can be analysed.\n\nAlso you may wish to check the little publications that I have made on RPubs."
  },
  {
    "objectID": "r-basics.html",
    "href": "r-basics.html",
    "title": "Introduction to R",
    "section": "",
    "text": "There are several ways to interact with R. The primary one will be through the command line, also known as console. The command line in RStudio is in the console panel. The name comes from it being the place where one types in commands.\n\n\n\nAn alternative way to interact with R is by typing all the code in an R script. In RStudio, click File &gt; New File &gt; R Script to open a new script. Changing line in the script won’t run the code, however. In order to run the line of code you need to press Ctrl + ENTER in Windows and cmd + ENTER in Mac. There are also commands to run the whole script, but let’s just keep it simple for the time being.\n\n\n\nIn first instance, R is a very powerful and fancy calculator. Typing in the command line numerical expressions with the usual mathematical operations, we get the results we expect:\n\n2 + 3\n\n[1] 5\n\n\nThe four operations in R are +, -, * and / and R follows the usual mathematical rules for the priority of the operations (the one that some people call BIDMAS).\n\n5 * 2 - 12 / 4\n\n[1] 7\n\n\nThe order of the operations can be altered using brackets, like so:\n\n(4 + 5 * 2) / (8 / 2 - 3)\n\n[1] 14\n\n\nBesides the four operations, R has some very useful other operations, such as the integer division %/% and the modulo %% of two numbers. The integer division gives the quotient of the division and the modulo gives the remainder of the division, like so:\n\n25 %/% 4\n\n[1] 6\n\n\n\n25 %% 4\n\n[1] 1\n\n\nIn fact, we have 25 = 6 x 4 + 1.\nWe can also perform powers with R. The syntax is a ^ n to produce a to the power of n. For example,\n\n3 ^ 4\n\n[1] 81\n\n\n\n\nR is also equipped with two special “values” that represent “true” and “false”. These are called the Boolean values and denoted in R by TRUE or T, and FALSE or F. These two special values can be joined together through the logical operations which are: and, or, and not. In R, and is represented by &, or by | and not by !. So, for example, we have:\n\nTRUE & FALSE\n\n[1] FALSE\n\nTRUE | FALSE\n\n[1] TRUE\n\n!FALSE\n\n[1] TRUE\n\n\nAgain, logical values can be linked together with brackets.\n\n\n\n\nOnce started understanding how R works with operations and numbers, we wish to start assigning values to variables and working with variables instead. R provides a special command to assign a value to a variable: &lt;-. This is called the assignment operator. For example\n\nx &lt;- 10\ny &lt;- 2.5\n\nx * y\n\n[1] 25\n\n\nYou don’t have to use a single letter to name a variable. Conversely, it is advisable not to do so, but to use meaningful words that recall the meaning of that variable. For example, to record the height and weight of an individual, we could use\n\nheight &lt;- 150\nweight &lt;- 65\n\n\n\n\n\n\n\nOn the names of variables\n\n\n\nA variable name must start with a letter, but it can contain also numbers, full stop, and underscore after the first letter. There are several different schools of thought about which is the best way to denote variables. In the past, I would have probably chosen a notation such as my.variable to indicate a variable, but after having coded for a long time alongside the magnificent data scientists and software engineers at Posit (former RStudio), I am now more used to a notation like my_variable which I do recommend.\n\n\nWe can work with variables joining them together with the usual operations. For example:\n\nbank_account &lt;- 100\ndeposit &lt;-  30\n\nbank_account &lt;- bank_account + deposit\n\nbank_account\n\n[1] 130\n\n\n\n\n\nUnlike programming languages such as C, Pascal, etc, R doesn’t require to state in advance the type of the variables but it assigns the data type automatically. In most simple cases, the user doesn’t really need bother about the data types, but in some cases, and especially when one starts working with data frames and working in machine learning, awareness of the variable type is very important, and the ability to change data type is paramount.\nR has many different data types. In what follows we shall go through the most important of them.\n\n\nThe most common data type is double, i.e. decimal numbers described using floating point values. Any number is stored in R as a double, unless otherwise specified. So, for example, the following are double.\n\na &lt;- 5\nb &lt;- 2.2\n\nTo see the type of these variable, we can use the command typeof. So\n\ntypeof(a)\n\n[1] \"double\"\n\ntypeof(b)\n\n[1] \"double\"\n\n\n\n\n\nTo tell R that we want the number to be an integer we need to add an L after the number during the assignment. For example\n\nn &lt;- 5L\n\nis an integer. To see this, let’s use again the typeof command:\n\ntypeof(n)\n\n[1] \"integer\"\n\n\nDouble and integer are referred to as numeric variables.\n\n\n\nR has also the possibility to store complex numbers. This is done using the key i for the imaginary unit. For example:\n\nz &lt;- 2 + 3i\nw &lt;- 5 + 2i\n\nIf variables are complex, R knows how to adapt the arithmetic operations to complex numbers. For example,\n\nz + w\n\n[1] 7+5i\n\n2 * z\n\n[1] 4+6i\n\n(1 - 2i) * w\n\n[1] 9-8i\n\n\n\n\n\nAs we have mentioned before, R has two Boolean values (true and false). Their type is logical.\n\np &lt;- TRUE\ntypeof(p)\n\n[1] \"logical\"\n\n\n\n\n\nAnother common type is character, which is the data type of characters and strings. To assign a character type to a variable, we use the quotation marks: both the single ' and the double \" quotation marks work.\n\nchar &lt;- \"Hello, world!\"\ntypeof(char)\n\n[1] \"character\"\n\n\n\n\n\n\n\n\nWarning\n\n\n\nBeside typeof, there is another command that shows the type of a variable: class.\n\n\n\n\n\n\nIn R we can use comparison operators to compare variables and return a logical value. The comparison operators are\n\n\n\nOperator\nName\nSyntax\n\n\n\n\n==\nequal\na == b\n\n\n!=\ndifferent\na != b\n\n\n&lt;=\nsmaller than, or equal to\na &lt;= b\n\n\n&lt;\nsmaller than\na &lt; b\n\n\n&gt;=\ngreater than, or equal to\na &gt;= b\n\n\n&gt;\ngreater than\na &gt; b\n\n\n\nFor example,\n\n5 &gt; 3\n\n[1] TRUE\n\n6 &lt; 3\n\n[1] FALSE\n\n\n\n\n\nBesides google searching and visiting Stack Overflow, there are some build-in functions to get help from R. In fact, most of the R functions have documentation and examples. To access the documentation of a function foo we can either use ?foo or help(foo). For example,\n\nhelp(vector)\n\nopens the documentation with title Vectors - Creation, Coercion, etc."
  },
  {
    "objectID": "r-basics.html#rs-command-line",
    "href": "r-basics.html#rs-command-line",
    "title": "Introduction to R",
    "section": "",
    "text": "There are several ways to interact with R. The primary one will be through the command line, also known as console. The command line in RStudio is in the console panel. The name comes from it being the place where one types in commands.\nIn first instance, R is a very powerful and fancy calculator. Typing in the command line numerical expressions with the usual mathematical operations, we get the results we expect:\n\n2 + 3\n\n[1] 5\n\n\nThe four operations in R are +, -, * and / and R follows the usual mathematical rules for the priority of the operations (the one that some people call BIDMAS).\n\n5 * 2 - 12 / 4\n\n[1] 7\n\n\nThe order of the operations can be altered using brackets, like so:\n\n(4 + 5 * 2) / (8 / 2 - 3)\n\n[1] 14\n\n\nBesides the four operations, R has some very useful other operations, such as the integer division %/% and the modulo %% of two numbers. The integer division gives the quotient of the division and the modulo gives the remainder of the division, like so:\n\n25 %/% 4\n\n[1] 6\n\n\n\n25 %% 4\n\n[1] 1\n\n\nIn fact:\n\n25 = 6 \\times 4 + 1\n\nWe can also perform powers with R. The syntax is a ^ n to produce a^n. For example,\n\n3 ^ 4\n\n[1] 81\n\n\n\n\nR is also equipped with two special “numbers” that represent “TRUE” and “FALSE”. These are TRUE or T and FALSE or F. These two special values can be joined together through the logical operations which are: and, or, and not. In R, and is represented by &, or by | and not by !. So, for example, we have:\n\nTRUE & FALSE\n\n[1] FALSE\n\nTRUE | FALSE\n\n[1] TRUE\n\n!FALSE\n\n[1] TRUE\n\n\nAgain, logical values can be linked together with brackets."
  },
  {
    "objectID": "r-basics.html#r-scripts",
    "href": "r-basics.html#r-scripts",
    "title": "Introduction to R",
    "section": "",
    "text": "Before going ahead and introducing variables, it is convenient to start putting our work into an R Script. In RStudio, click File &gt; New File &gt; R Script to open a new script. Changing line in the script won’t run the code, however. In order to run the line of code you may press Ctrl + ENTER in Windows and cmd + ENTER in Mac. There are also commands to run the whole script, but let’s just keep it simple for the time being.\n\n\nOnce started understanding how R works with operations and numbers, we wish to start assigning values to variables and working with variables instead. R provides a special command to assign a value to a variable: &lt;-. This is called the assignment operator. For example\n\nx &lt;- 10\ny &lt;- 2.5\n\nx * y\n\n[1] 25\n\n\nYou don’t have to use a single letter to name a variable. Conversely, it is advisable not to do so, but to use meaningful words that recall the meaning of that variable. For example, to record the height and weight of an individual, we could use\n\nheight &lt;- 150\nweight &lt;- 65\n\n\n\n\n\n\n\nOn the names of variables\n\n\n\nA variable name must start with a letter, but it can contain also numbers, full stop, and underscore after the first letter. There are several different schools of thought about which is the best way to denote variables. In the past, I would have probably chosen a notation such as my.variable to indicate a variable, but after having coded for a long time alongside the magnificent data scientists and software engineers at Posit (former RStudio), I am now more used to a notation like my_variable which I do recommend.\n\n\nWe can work with variables joining them together with the usual operations. For example:\n\nbank_account &lt;- 100\ndeposit &lt;-  30\n\nbank_account &lt;- bank_account + deposit\n\nbank_account\n\n[1] 130\n\n\n\n\n\nR is a statistical software and in statistics a variable scarcely has only one value, but it is generally given as a list of values (measures). For example, one could have a variable age of the ages of all the employees of a small business. To store this in R, we can use the command c which stands for concatenate. For example\n\nages &lt;- c(25, 33, 45, 37, 28, 23, 42, 58, 29)\n\nNow the variable age is a vector. Let’s find out the length of this vector.\n\nlength(ages)\n\n[1] 9\n\n\nWe may also want to find out the average age of the employees of the business. This can be done with the command mean. E.g.\n\nmean(ages)\n\n[1] 35.55556\n\n\nOther statistical operations are median to calculate the median, IQR to find the interquartile range, sd to find the standard deviation and summary to show a five number summary of the variable, i.e. the minimum, lower quartile, median, upper quartile and maximum in the vector. The function summary also shows the mean.\n\nsummary(ages)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  23.00   28.00   33.00   35.56   42.00   58.00 \n\n\nIt is interesting to immediately notice that R functions may give different outcomes depending on the type of the variable. We shall come back to the type of a variable, but for the moment let’s just say that we consider an employee to be a junior employee if their age is below 33 years. To check whether the ages are below 33 we can use the normal order operations &lt; and &gt;.\n\nis_junior &lt;- ages &lt;= 33\nis_junior\n\n[1]  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE\n\n\nIf we now run the summary command on the variable is_junior we no longer get a five number summary because the variable is_junior is not numeric.\n\nsummary(is_junior)\n\n   Mode   FALSE    TRUE \nlogical       4       5"
  },
  {
    "objectID": "r-basics.html#operations-in-r",
    "href": "r-basics.html#operations-in-r",
    "title": "Introduction to R",
    "section": "",
    "text": "In first instance, R is a very powerful and fancy calculator. Typing in the command line numerical expressions with the usual mathematical operations, we get the results we expect:\n\n2 + 3\n\n[1] 5\n\n\nThe four operations in R are +, -, * and / and R follows the usual mathematical rules for the priority of the operations (the one that some people call BIDMAS).\n\n5 * 2 - 12 / 4\n\n[1] 7\n\n\nThe order of the operations can be altered using brackets, like so:\n\n(4 + 5 * 2) / (8 / 2 - 3)\n\n[1] 14\n\n\nBesides the four operations, R has some very useful other operations, such as the integer division %/% and the modulo %% of two numbers. The integer division gives the quotient of the division and the modulo gives the remainder of the division, like so:\n\n25 %/% 4\n\n[1] 6\n\n\n\n25 %% 4\n\n[1] 1\n\n\nIn fact:\n\n25 = 6 \\times 4 + 1\n\nWe can also perform powers with R. The syntax is a ^ n to produce a^n. For example,\n\n3 ^ 4\n\n[1] 81\n\n\n\n\nR is also equipped with two special “numbers” that represent “TRUE” and “FALSE”. These are TRUE or T and FALSE or F. These two special values can be joined together through the logical operations which are: and, or, and not. In R, and is represented by &, or by | and not by !. So, for example, we have:\n\nTRUE & FALSE\n\n[1] FALSE\n\nTRUE | FALSE\n\n[1] TRUE\n\n!FALSE\n\n[1] TRUE\n\n\nAgain, logical values can be linked together with brackets.\n\n\n\nOnce started understanding how R works with operations and numbers, we wish to start assigning values to variables and working with variables instead. R provides a special command to assign a value to a variable: &lt;-. This is called the assignment operator. For example\n\nx &lt;- 10\ny &lt;- 2.5\n\nx * y\n\n[1] 25\n\n\nYou don’t have to use a single letter to name a variable. Conversely, it is advisable not to do so, but to use meaningful words that recall the meaning of that variable. For example, to record the height and weight of an individual, we could use\n\nheight &lt;- 150\nweight &lt;- 65\n\n\n\n\n\n\n\nOn the names of variables\n\n\n\nA variable name must start with a letter, but it can contain also numbers, full stop, and underscore after the first letter. There are several different schools of thought about which is the best way to denote variables. In the past, I would have probably chosen a notation such as my.variable to indicate a variable, but after having coded for a long time alongside the magnificent data scientists and software engineers at Posit (former RStudio), I am now more used to a notation like my_variable which I do recommend.\n\n\nWe can work with variables joining them together with the usual operations. For example:\n\nbank_account &lt;- 100\ndeposit &lt;-  30\n\nbank_account &lt;- bank_account + deposit\n\nbank_account\n\n[1] 130\n\n\n\n\n\nR is a statistical software and in statistics a variable scarcely has only one value, but it is generally given as a list of values (measures). For example, one could have a variable age of the ages of all the employees of a small business. To store this in R, we can use the command c which stands for concatenate. For example\n\nages &lt;- c(25, 33, 45, 37, 28, 23, 42, 58, 29)\n\nNow the variable age is a vector. Let’s find out the length of this vector.\n\nlength(ages)\n\n[1] 9\n\n\nWe may also want to find out the average age of the employees of the business. This can be done with the command mean. E.g.\n\nmean(ages)\n\n[1] 35.55556\n\n\nOther statistical operations are median to calculate the median, IQR to find the interquartile range, sd to find the standard deviation and summary to show a five number summary of the variable, i.e. the minimum, lower quartile, median, upper quartile and maximum in the vector. The function summary also shows the mean.\n\nsummary(ages)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  23.00   28.00   33.00   35.56   42.00   58.00 \n\n\nIt is interesting to immediately notice that R functions may give different outcomes depending on the type of the variable. We shall come back to the type of a variable, but for the moment let’s just say that we consider an employee to be a junior employee if their age is below 33 years. To check whether the ages are below 33 we can use the normal order operations &lt; and &gt;.\n\nis_junior &lt;- ages &lt;= 33\nis_junior\n\n[1]  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE\n\n\nIf we now run the summary command on the variable is_junior we no longer get a five number summary because the variable is_junior is not numeric.\n\nsummary(is_junior)\n\n   Mode   FALSE    TRUE \nlogical       4       5"
  },
  {
    "objectID": "r-basics.html#arithmetic-with-r",
    "href": "r-basics.html#arithmetic-with-r",
    "title": "Introduction to R",
    "section": "",
    "text": "In first instance, R is a very powerful and fancy calculator. Typing in the command line numerical expressions with the usual mathematical operations, we get the results we expect:\n\n2 + 3\n\n[1] 5\n\n\nThe four operations in R are +, -, * and / and R follows the usual mathematical rules for the priority of the operations (the one that some people call BIDMAS).\n\n5 * 2 - 12 / 4\n\n[1] 7\n\n\nThe order of the operations can be altered using brackets, like so:\n\n(4 + 5 * 2) / (8 / 2 - 3)\n\n[1] 14\n\n\nBesides the four operations, R has some very useful other operations, such as the integer division %/% and the modulo %% of two numbers. The integer division gives the quotient of the division and the modulo gives the remainder of the division, like so:\n\n25 %/% 4\n\n[1] 6\n\n\n\n25 %% 4\n\n[1] 1\n\n\nIn fact, we have 25 = 6 x 4 + 1.\nWe can also perform powers with R. The syntax is a ^ n to produce a to the power of n. For example,\n\n3 ^ 4\n\n[1] 81\n\n\n\n\nR is also equipped with two special “values” that represent “true” and “false”. These are called the Boolean values and denoted in R by TRUE or T, and FALSE or F. These two special values can be joined together through the logical operations which are: and, or, and not. In R, and is represented by &, or by | and not by !. So, for example, we have:\n\nTRUE & FALSE\n\n[1] FALSE\n\nTRUE | FALSE\n\n[1] TRUE\n\n!FALSE\n\n[1] TRUE\n\n\nAgain, logical values can be linked together with brackets."
  },
  {
    "objectID": "r-basics.html#variables-and-assignment",
    "href": "r-basics.html#variables-and-assignment",
    "title": "Introduction to R",
    "section": "",
    "text": "Once started understanding how R works with operations and numbers, we wish to start assigning values to variables and working with variables instead. R provides a special command to assign a value to a variable: &lt;-. This is called the assignment operator. For example\n\nx &lt;- 10\ny &lt;- 2.5\n\nx * y\n\n[1] 25\n\n\nYou don’t have to use a single letter to name a variable. Conversely, it is advisable not to do so, but to use meaningful words that recall the meaning of that variable. For example, to record the height and weight of an individual, we could use\n\nheight &lt;- 150\nweight &lt;- 65\n\n\n\n\n\n\n\nOn the names of variables\n\n\n\nA variable name must start with a letter, but it can contain also numbers, full stop, and underscore after the first letter. There are several different schools of thought about which is the best way to denote variables. In the past, I would have probably chosen a notation such as my.variable to indicate a variable, but after having coded for a long time alongside the magnificent data scientists and software engineers at Posit (former RStudio), I am now more used to a notation like my_variable which I do recommend.\n\n\nWe can work with variables joining them together with the usual operations. For example:\n\nbank_account &lt;- 100\ndeposit &lt;-  30\n\nbank_account &lt;- bank_account + deposit\n\nbank_account\n\n[1] 130"
  },
  {
    "objectID": "r-basics.html#r-data-types",
    "href": "r-basics.html#r-data-types",
    "title": "Introduction to R",
    "section": "",
    "text": "Unlike programming languages such as C, Pascal, etc, R doesn’t require to state in advance the type of the variables but it assigns the data type automatically. In most simple cases, the user doesn’t really need bother about the data types, but in some cases, and especially when one starts working with data frames and working in machine learning, awareness of the variable type is very important, and the ability to change data type is paramount.\nR has many different data types. In what follows we shall go through the most important of them.\n\n\nThe most common data type is double, i.e. decimal numbers described using floating point values. Any number is stored in R as a double, unless otherwise specified. So, for example, the following are double.\n\na &lt;- 5\nb &lt;- 2.2\n\nTo see the type of these variable, we can use the command typeof. So\n\ntypeof(a)\n\n[1] \"double\"\n\ntypeof(b)\n\n[1] \"double\"\n\n\n\n\n\nTo tell R that we want the number to be an integer we need to add an L after the number during the assignment. For example\n\nn &lt;- 5L\n\nis an integer. To see this, let’s use again the typeof command:\n\ntypeof(n)\n\n[1] \"integer\"\n\n\nDouble and integer are referred to as numeric variables.\n\n\n\nR has also the possibility to store complex numbers. This is done using the key i for the imaginary unit. For example:\n\nz &lt;- 2 + 3i\nw &lt;- 5 + 2i\n\nIf variables are complex, R knows how to adapt the arithmetic operations to complex numbers. For example,\n\nz + w\n\n[1] 7+5i\n\n2 * z\n\n[1] 4+6i\n\n(1 - 2i) * w\n\n[1] 9-8i\n\n\n\n\n\nAs we have mentioned before, R has two Boolean values (true and false). Their type is logical.\n\np &lt;- TRUE\ntypeof(p)\n\n[1] \"logical\"\n\n\n\n\n\nAnother common type is character, which is the data type of characters and strings. To assign a character type to a variable, we use the quotation marks: both the single ' and the double \" quotation marks work.\n\nchar &lt;- \"Hello, world!\"\ntypeof(char)\n\n[1] \"character\"\n\n\n\n\n\n\n\n\nWarning\n\n\n\nBeside typeof, there is another command that shows the type of a variable: class."
  },
  {
    "objectID": "r-basics.html#comparison-operators",
    "href": "r-basics.html#comparison-operators",
    "title": "Introduction to R",
    "section": "",
    "text": "In R we can use comparison operators to compare variables and return a logical value. The comparison operators are\n\n\n\nOperator\nName\nSyntax\n\n\n\n\n==\nequal\na == b\n\n\n!=\ndifferent\na != b\n\n\n&lt;=\nsmaller than, or equal to\na &lt;= b\n\n\n&lt;\nsmaller than\na &lt; b\n\n\n&gt;=\ngreater than, or equal to\na &gt;= b\n\n\n&gt;\ngreater than\na &gt; b\n\n\n\nFor example,\n\n5 &gt; 3\n\n[1] TRUE\n\n6 &lt; 3\n\n[1] FALSE"
  },
  {
    "objectID": "vectors.html",
    "href": "vectors.html",
    "title": "Vectors",
    "section": "",
    "text": "R is a statistical software and in statistics a variable scarcely has only one value, but it is generally given as a list of values (measurements). For example, one could have a variable ages of the ages of all the employees of a small business. To store this in R, we can use the function c() which stands for concatenate. To use this function, we pass the values of the vector as a list, separated by a comma. For example\n\nages &lt;- c(25, 33, 45, 37, 28, 23, 42, 58, 29)\nages\n\n[1] 25 33 45 37 28 23 42 58 29\n\n\nNow the variable ages is a vector. Let’s find out the length of this vector.\n\nlength(ages)\n\n[1] 9\n\n\n\n\nWe can create vectors with any data type. For example,\n\nnvec &lt;- c(1, 2, 3, 4, 5)\ntypeof(nvec)\n\n[1] \"double\"\n\ncvec &lt;- c(\"G\", \"C\", \"S\", \"E\")\ntypeof(cvec)\n\n[1] \"character\"\n\nlvec &lt;- c(TRUE, FALSE)\ntypeof(lvec)\n\n[1] \"logical\"\n\n\nIt is important to note now that all the elements of a vector must all have the same type. In fact, if we attempt to mix data types in a vector, R will convert them to force them to have all the same data type. For example,\n\nv &lt;- c(FALSE, 3, TRUE, 6)\ntypeof(v)\n\n[1] \"double\"\n\n\nIn fact, R will convert TRUE as 1 and FALSE as 0.\n\nw &lt;- c(\"A\", 1)\ntypeof(w)\n\n[1] \"character\"\n\n\nIn this case, as we could imagine, R converts everything to be a character.\n\nw\n\n[1] \"A\" \"1\"\n\n\n\n\n\nAn interesting feature of R is that each element in a vector can be named. Precisely, we can use the function name() to assign to each element of a vector a name. For example, imagine the following vector contains a week of temperatures:\n\ntemp &lt;- c(18, 16, 17, 17, 18, 16, 15)\ntemp\n\n[1] 18 16 17 17 18 16 15\n\n\nWe know that we have 7 temperatures for the 7 days of the week, but which temperature corresponds to which day? Does it start from Monday or from Sunday, or another day of the week? This is where the function name() can be used to assign a label to each value of the vector temp, as follows:\n\ndays &lt;- c(\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\")\nnames(temp) &lt;- days\ntemp\n\nMon Tue Wed Thu Fri Sat Sun \n 18  16  17  17  18  16  15 \n\n\n\n\n\n\nAs we have mentioned a couple of times already, R is a statistical software. This means that all aspects of R are centred on working with statistical data. Therefore, performing operations in R is specifically designed to make working with data as simple as possible. In particular, all arithmetic operations are vectorised, which means that the operations occur on an element by element basis. for example, take the following two vectors:\n\nvec_1 &lt;- c(1, 2, 3)\nvec_2 &lt;- c(5, 6, 7)\n\nAdding vectors:\n\nvec_1 + vec_2\n\n[1]  6  8 10\n\n\nSubtracting vectors:\n\nvec_1 - vec_2\n\n[1] -4 -4 -4\n\n\nMultiplying vectors:\n\nvec_1 * vec_2\n\n[1]  5 12 21\n\n\nDividing vectors:\n\nvec_1 / vec_2\n\n[1] 0.2000000 0.3333333 0.4285714\n\n\n\n\nWe can apply comparison operations of a single number to an entire vector. R will apply the comparison to every element of the vector, like so:\n\nvec &lt;- c(1, 2, 3, 4, 5, 6)\nvec &lt; 3.5\n\n[1]  TRUE  TRUE  TRUE FALSE FALSE FALSE\n\nvec == 2\n\n[1] FALSE  TRUE FALSE FALSE FALSE FALSE\n\n\n\n\n\nLet’s come back to the example of the age of the employees of a business, ages. Imagine we wish to find the mean of the ages. To do so, we can use the function mean(), like so:\nmean(ages)\nSimilarly, we could find the median, the standard deviation, the interquartile range (IQR), etc, with similar functions. The following table contains some of the most common mathematical functions in R. A more comprehensive list of functions can be find in the R Reference Card published on CRAN.\n\n\n\n\n\n\n\nFunction\nMeaning\n\n\n\n\nsum(x)\nsum of the elements of x\n\n\nmin(x)\nminimum of the elements of x\n\n\nmax(x)\nmaximum of the elements of x\n\n\nmean(x)\nmean of the elements of x\n\n\nmedian(x)\nmedian of the elements of x\n\n\nquantile(x, probs)\nsample quantiles corresponding to the given probabilities (defaults to 0, 0.25, 0.5, 0.75, 1)\n\n\nvar(x)\nvariance of the elements of x (calculated on n-1)\n\n\nsd(x)\nstandard deviation of x (square root of the variance)\n\n\nIQR(x)\ninterquartile range of x\n\n\nlog(x, base)\ncomputes the logarithm of x with base base (default e, the natural logarithm)\n\n\n\nAnother very nice function is summary() which returns a summary statistics of the vector, i.e. the minimum, lower quartile, median, mean, upper quartile and maximum of the vector. For example,\n\nsummary(ages)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  23.00   28.00   33.00   35.56   42.00   58.00 \n\n\nIt is interesting to notice that R functions may give different outcomes depending on the type of the variable. We shall come back to the type of a variable, but for the moment let’s just say that we consider an employee to be a junior employee if their age is below 33 years. To check whether the ages are below 33 we can use the comparison operators, like so:\n\nis_junior &lt;- ages &lt;= 33\nis_junior\n\n[1]  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE\n\n\nIf we now run the summary command on the variable is_junior we no longer get a five number summary because the variable is_junior is not numeric.\n\nsummary(is_junior)\n\n   Mode   FALSE    TRUE \nlogical       4       5 \n\n\n\n\n\n\nIt is sometimes important to be able to access a particular element of a given vector. For example, consider the following vector:\n\nvec &lt;- c(5, 10, 15, 20, 25, 30, 35, 40)\n\nWe can use the square brackets [ ] to access the individual elements of the vector. This can be done by indexing. In its simplest form, indexing works by using the brackets to pass the index position corresponding to the element as a number. Keep in mind that, unlike python, in R the index position starts at 1. So, for example,\n\nvec[3]\n\n[1] 15\n\n\nSometimes, however, we wish to access multiple elements at the same time. This can be done passing a vector of indices inside the square brackets; like so:\n\nvec[c(2, 3, 5)]\n\n[1] 10 15 25\n\n\nIf we pass a negative index to the vector, R will instead return the vector with all but the index passed. For example,\n\nvec[-3]\n\n[1]  5 10 20 25 30 35 40\n\n\n\n\nWe can also use the colon (:) to indicate a slice of vector. The colon operator from:to creates a vector of numbers that starts from from and ends at to, increasing by 1 unit every time. So, for example,\n\n3:7\n\n[1] 3 4 5 6 7\n\n\nNotice that if decimal numbers are given, it is possible that the second number is not necessarily part of the list, because the sequence terminates with the bigger number smaller than to, like so:\n\n3.5:7.2\n\n[1] 3.5 4.5 5.5 6.5\n\n\nSo, using the colon, we can get a slice of a vector, using the following syntax:\nvector[start_index:stop_index]\nFor example,\n\nvec[2:4]\n\n[1] 10 15 20\n\n\nNotice how the elements both at the starting and stopping index are included.\n\n\n\nWe have previously seen that we can assign names to the elements of a vector. For example,\n\nvec &lt;- c(5, 10, 15, 20, 25)\nnames(vec) &lt;- c(\"a\", \"b\", \"c\", \"d\", \"e\")\nvec\n\n a  b  c  d  e \n 5 10 15 20 25 \n\n\nWe can then use the name along with the indexing brackets to grab the individual elements from the vector.\n\nvec[\"c\"]\n\n c \n15 \n\n\nAgain, we can also pass a vector of names to grab more than one vector at the same time.\n\nvec[c(\"a\", \"c\", \"e\")]\n\n a  c  e \n 5 15 25 \n\n\n\n\n\nAs we have mentioned before, talking about the comparison operators with vectors, we can use comparison operators to filter out elements from a vector. Sometimes this is referred to as boolean/logical masking, because we are creating a vector of logicals to filter out results you want.\nLet’s see an example of this. Take the vector\n\nvec &lt;- 1:10\nvec\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nWe can pass to the brackets a logical statement.\n\nvec[vec &gt; 6]\n\n[1]  7  8  9 10\n\n\nLet’s break this down to see how it works. First, let’s have a look at the vector\n\nvec &gt; 6\n\n [1] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\n\n\nAs we can see, it returns a logical vector with the same length as vec whose elements says whether it is true or false that the element in that position is greater than 6. When we pass a logical vector, such as this, to another vector through the brackets, R will return only the elements of the vector corresponding to a true value in the logical vector.\nTo make this more clear, we could even assign a name to this logical vector and pass the name to the vector, like so:\n\nfilter &lt;- vec &gt; 6\nfilter\n\n [1] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\n\nvec[filter]\n\n[1]  7  8  9 10\n\n\n\n\n\n\nBesides the function c() we have already seen that the colon operator from:to generates a sequence starting at from and ending at to. Another function that does the same job is seq(from, to, by = ). The parameter by specifies the increment of the sequence and its default value is 1. So, for example,\n\nseq(5, 16, by = 2)\n\n[1]  5  7  9 11 13 15\n\n\nAnother function that creates a vector is rep(x, times) which repeats the vector x times times.\n\nrep(c(1, 2), times = 3)\n\n[1] 1 2 1 2 1 2\n\n\nThe function rep has an alternative parameter each which repeats ‘each’ element of x each times. For example,\n\nrep(c(1, 2), each = 3)\n\n[1] 1 1 1 2 2 2\n\n\n\n\n\nSometimes instead of generating data with a pattern, we would like to simulate data. R is perfect for this job, as it has a very good implementation of all the most common and important statistical distributions needed. However, before we can simulate data, it is vital to say a few words about random data generation and reproducibility.\n\n\nAccording to Wikipedia, random number generation is a process by which, often by means of a random number generator (RGN), a sequence of numbers or symbols that cannot be reasonably predicted better than by random chance is generated. True random number generators are generally hardware based (for example by rolling a die). Software typically use a pseudo-random number generator (PRNG) which is an algorithm that generates a sequence of numbers that only looks random but that is in fact pre-determined. On Wikipedia there is long list of PRNGs, but for our scope, suffices it to say that the numbers that can be generated by R are in actual facts not random, but they would pass a random test, which means that they would look random from a mathematical point of view. If you want to know more about how R generates random numbers, you may wish to type help(\"RNG\") on your console.\n\n\n\nThis may look like a disadvantage, but it is actually a very important aspect of simulation. By means of the fact that random numbers are not-random after all, this means that if we “set a seed” we can then reproduce the exact random sequence again. This means that different user can perform the same simulation, obtaining the same result, as long as they use the same PRNG and they set the same seed.\nIn R the command to set the PRNG seed is set.seed().\nThis function needs to be assigned a number, the seed, which starts the sequence.\n\n\n\nLet’s see an example. Imagine we wish to roll a die. This means that we have a set of six possible outcomes (coded as 1 to 6), and by rolling a fair die we select one of them and all of them have the same probability (1 out of 6) to be selected. This can be done easily by sampling the set 1 to 6, i.e.\n\nset.seed(123)\nsample(1:6, 1)\n\n[1] 3\n\n\nImagine now we want to roll our die 10 times. This can be simulated using a similar code: we need to sample 10 times the set 1 to 6, but this sample must be with replacement. Thus we need to add the parameter replace = TRUE to the code to ensure that R samples with replacement. Let’s also set the same seed.\n\nset.seed(123)\nsample(1:6, 10, replace = TRUE)\n\n [1] 3 6 3 2 2 6 3 5 4 6\n\n\nWe may notice that having set the same seed, the first number is exactly the same as before.\n\n\n\n\n\n\nCaution\n\n\n\nA note of caution here: it is a good practice to set the seed every time we use a random generator function. In fact, once the seed has been set, the random function will use the PRGN in a specific way and different versions of the same function might use the PRNG in different ways. So once we access the PRNG again, it is good to always maintain control by choosing the seed, to ensure reproducibility.\n\n\n\n\n\nSuppose now we want to simulate a measurement (e.g. the temperature of a town). In this case we can’t sample from a population, but we need to use a statistical distribution. The statistical distribution that models a measurement is called the normal distribution and it has two parameters: the mean and the standard deviation. The mean represents the typical value of this measurement, and the standard deviation represent an approximation of the error made in taking this measurement.\nSo let’s run a simulation of 10 measurements of an average temperature of 18 degrees with a variability of 3 degrees.\n\nset.seed(101)\nrnorm(10, mean = 18, sd = 3)\n\n [1] 17.02189 19.65739 15.97517 18.64308 18.93231 21.52190 19.85637 17.66180\n [9] 20.75108 17.33022\n\n\nThis is way too accurate: let’s just round this to integers.\n\nset.seed(101)\nround(rnorm(10, mean = 18, sd = 3))\n\n [1] 17 20 16 19 19 22 20 18 21 17\n\n\nAnother very common distribution is the so called uniform distribution which gives the same probability to all numbers between a minimum and a maximum chosen numbers (defaults are min = 0 and max = 1). Let’s simulate 100 values from a uniform distribution:\n\nset.seed(111)\nrunif(100)\n\n  [1] 0.5929812845 0.7264811215 0.3704220036 0.5149238301 0.3776632159\n  [6] 0.4183373258 0.0106578451 0.5322952422 0.4321606164 0.0936815199\n [11] 0.5557799137 0.5902284889 0.0671411434 0.0475478533 0.1562025158\n [16] 0.4464277634 0.1714436871 0.9665342933 0.3106664298 0.6144663957\n [21] 0.4310607871 0.2855270915 0.3421513471 0.3866276275 0.9675274789\n [26] 0.3220267275 0.6532294548 0.2833034997 0.7874279192 0.5959206352\n [31] 0.0585964625 0.5098998600 0.4657924296 0.4693590938 0.3597453721\n [36] 0.7134103531 0.1163154817 0.7839926207 0.6421407105 0.8051009134\n [41] 0.6411978584 0.3284916454 0.6356909545 0.9285191579 0.5752422044\n [46] 0.3666838536 0.4366072204 0.8559219379 0.6279955737 0.7937756432\n [51] 0.7251648332 0.5850447209 0.0327716474 0.3329946804 0.9967166614\n [56] 0.5482733699 0.5758329388 0.4563152066 0.0965785654 0.8055401752\n [61] 0.0009253006 0.4667440471 0.1732608730 0.2592225648 0.9192820815\n [66] 0.2319295844 0.0525656715 0.3043926249 0.0117258150 0.3007076983\n [71] 0.8775839461 0.6652787277 0.4537648347 0.0533223320 0.6309068091\n [76] 0.4421851884 0.2673464869 0.9837744189 0.0951241532 0.7859691235\n [81] 0.1198521818 0.8812154671 0.1310980669 0.4003378763 0.0866140136\n [86] 0.3747997992 0.6847860171 0.7347726757 0.7709477365 0.5799853499\n [91] 0.5110989846 0.8529837073 0.6298211562 0.5790059080 0.7402492894\n [96] 0.3871497631 0.9935344572 0.3980894811 0.9750010339 0.8244822009\n\n\nThe table below shows the most common distributions with their syntax and a brief explanation.\n\n\n\n\n\n\n\n\nName\nSynatx\nExample of usage\n\n\n\n\nNormal distribution\nrnorm(n, mean = 0, sd = 1)\nThe normal distribution models measurements with mean mean and error sd\n\n\nUniform distribution\nrunif(n, min = 0, max = 1)\nThe uniform distribution is generally used to generate a sequence of random numbers\n\n\nBinomial distribution\nrbinom(n, size, prob)\nThe binomial distribution models the number of successes in size trials with probability of success prob\n\n\nPoisson distribution\nrpois(n, lambda)\nThe Poisson distribution is also called the “count” distribution: it models the number of events occurring at a constant rate in a given time frame. lambda is the mean number of events occurring.\n\n\nExponential distribution\nrexp(n, rate = 1)\nThe exponential distribution models the time to wait until the next event occurs, such as a failure or a success. rate is the average rate at which the events occur.\n\n\nGeometric distribution\nrgeom(n, prob)\nThe geometric distribution models the instant of first success in a sequence of trials with probability of success prob"
  },
  {
    "objectID": "vectors.html#vector-basics",
    "href": "vectors.html#vector-basics",
    "title": "Vectors",
    "section": "",
    "text": "R is a statistical software and in statistics a variable scarcely has only one value, but it is generally given as a list of values (measurements). For example, one could have a variable ages of the ages of all the employees of a small business. To store this in R, we can use the function c() which stands for concatenate. To use this function, we pass the values of the vector as a list, separated by a comma. For example\n\nages &lt;- c(25, 33, 45, 37, 28, 23, 42, 58, 29)\nages\n\n[1] 25 33 45 37 28 23 42 58 29\n\n\nNow the variable ages is a vector. Let’s find out the length of this vector.\n\nlength(ages)\n\n[1] 9\n\n\n\n\nWe can create vectors with any data type. For example,\n\nnvec &lt;- c(1, 2, 3, 4, 5)\ntypeof(nvec)\n\n[1] \"double\"\n\ncvec &lt;- c(\"G\", \"C\", \"S\", \"E\")\ntypeof(cvec)\n\n[1] \"character\"\n\nlvec &lt;- c(TRUE, FALSE)\ntypeof(lvec)\n\n[1] \"logical\"\n\n\nIt is important to note now that all the elements of a vector must all have the same type. In fact, if we attempt to mix data types in a vector, R will convert them to force them to have all the same data type. For example,\n\nv &lt;- c(FALSE, 3, TRUE, 6)\ntypeof(v)\n\n[1] \"double\"\n\n\nIn fact, R will convert TRUE as 1 and FALSE as 0.\n\nw &lt;- c(\"A\", 1)\ntypeof(w)\n\n[1] \"character\"\n\n\nIn this case, as we could imagine, R converts everything to be a character.\n\nw\n\n[1] \"A\" \"1\"\n\n\n\n\n\nAn interesting feature of R is that each element in a vector can be named. Precisely, we can use the function name() to assign to each element of a vector a name. For example, imagine the following vector contains a week of temperatures:\n\ntemp &lt;- c(18, 16, 17, 17, 18, 16, 15)\ntemp\n\n[1] 18 16 17 17 18 16 15\n\n\nWe know that we have 7 temperatures for the 7 days of the week, but which temperature corresponds to which day? Does it start from Monday or from Sunday, or another day of the week? This is where the function name() can be used to assign a label to each value of the vector temp, as follows:\n\ndays &lt;- c(\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\")\nnames(temp) &lt;- days\ntemp\n\nMon Tue Wed Thu Fri Sat Sun \n 18  16  17  17  18  16  15"
  },
  {
    "objectID": "vectors.html#operations-with-vectors",
    "href": "vectors.html#operations-with-vectors",
    "title": "Vectors",
    "section": "",
    "text": "As we have mentioned a couple of times already, R is a statistical software. This means that all aspects of R are centred on working with statistical data. Therefore, performing operations in R is specifically designed to make working with data as simple as possible. In particular, all arithmetic operations are vectorised, which means that the operations occur on an element by element basis. for example, take the following two vectors:\n\nvec_1 &lt;- c(1, 2, 3)\nvec_2 &lt;- c(5, 6, 7)\n\nAdding vectors:\n\nvec_1 + vec_2\n\n[1]  6  8 10\n\n\nSubtracting vectors:\n\nvec_1 - vec_2\n\n[1] -4 -4 -4\n\n\nMultiplying vectors:\n\nvec_1 * vec_2\n\n[1]  5 12 21\n\n\nDividing vectors:\n\nvec_1 / vec_2\n\n[1] 0.2000000 0.3333333 0.4285714\n\n\n\n\nWe can apply comparison operations of a single number to an entire vector. R will apply the comparison to every element of the vector, like so:\n\nvec &lt;- c(1, 2, 3, 4, 5, 6)\nvec &lt; 3.5\n\n[1]  TRUE  TRUE  TRUE FALSE FALSE FALSE\n\nvec == 2\n\n[1] FALSE  TRUE FALSE FALSE FALSE FALSE\n\n\n\n\n\nLet’s come back to the example of the age of the employees of a business, ages. Imagine we wish to find the mean of the ages. To do so, we can use the function mean(), like so:\nmean(ages)\nSimilarly, we could find the median, the standard deviation, the interquartile range (IQR), etc, with similar functions. The following table contains some of the most common mathematical functions in R. A more comprehensive list of functions can be find in the R Reference Card published on CRAN.\n\n\n\n\n\n\n\nFunction\nMeaning\n\n\n\n\nsum(x)\nsum of the elements of x\n\n\nmin(x)\nminimum of the elements of x\n\n\nmax(x)\nmaximum of the elements of x\n\n\nmean(x)\nmean of the elements of x\n\n\nmedian(x)\nmedian of the elements of x\n\n\nquantile(x, probs)\nsample quantiles corresponding to the given probabilities (defaults to 0, 0.25, 0.5, 0.75, 1)\n\n\nvar(x)\nvariance of the elements of x (calculated on n-1)\n\n\nsd(x)\nstandard deviation of x (square root of the variance)\n\n\nIQR(x)\ninterquartile range of x\n\n\nlog(x, base)\ncomputes the logarithm of x with base base (default e, the natural logarithm)\n\n\n\nAnother very nice function is summary() which returns a summary statistics of the vector, i.e. the minimum, lower quartile, median, mean, upper quartile and maximum of the vector. For example,\n\nsummary(ages)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  23.00   28.00   33.00   35.56   42.00   58.00 \n\n\nIt is interesting to notice that R functions may give different outcomes depending on the type of the variable. We shall come back to the type of a variable, but for the moment let’s just say that we consider an employee to be a junior employee if their age is below 33 years. To check whether the ages are below 33 we can use the comparison operators, like so:\n\nis_junior &lt;- ages &lt;= 33\nis_junior\n\n[1]  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE\n\n\nIf we now run the summary command on the variable is_junior we no longer get a five number summary because the variable is_junior is not numeric.\n\nsummary(is_junior)\n\n   Mode   FALSE    TRUE \nlogical       4       5"
  },
  {
    "objectID": "r-basics.html#getting-help-with-r",
    "href": "r-basics.html#getting-help-with-r",
    "title": "Introduction to R",
    "section": "",
    "text": "Besides google searching and visiting Stack Overflow, there are some build-in functions to get help from R. In fact, most of the R functions have documentation and examples. To access the documentation of a function foo we can either use ?foo or help(foo). For example,\n\nhelp(vector)\n\nopens the documentation with title Vectors - Creation, Coercion, etc."
  },
  {
    "objectID": "vectors.html#vector-indexing-and-slicing",
    "href": "vectors.html#vector-indexing-and-slicing",
    "title": "Vectors",
    "section": "",
    "text": "It is sometimes important to be able to access a particular element of a given vector. For example, consider the following vector:\n\nvec &lt;- c(5, 10, 15, 20, 25, 30, 35, 40)\n\nWe can use the square brackets [ ] to access the individual elements of the vector. This can be done by indexing. In its simplest form, indexing works by using the brackets to pass the index position corresponding to the element as a number. Keep in mind that, unlike python, in R the index position starts at 1. So, for example,\n\nvec[3]\n\n[1] 15\n\n\nSometimes, however, we wish to access multiple elements at the same time. This can be done passing a vector of indices inside the square brackets; like so:\n\nvec[c(2, 3, 5)]\n\n[1] 10 15 25\n\n\nIf we pass a negative index to the vector, R will instead return the vector with all but the index passed. For example,\n\nvec[-3]\n\n[1]  5 10 20 25 30 35 40\n\n\n\n\nWe can also use the colon (:) to indicate a slice of vector. The colon operator from:to creates a vector of numbers that starts from from and ends at to, increasing by 1 unit every time. So, for example,\n\n3:7\n\n[1] 3 4 5 6 7\n\n\nNotice that if decimal numbers are given, it is possible that the second number is not necessarily part of the list, because the sequence terminates with the bigger number smaller than to, like so:\n\n3.5:7.2\n\n[1] 3.5 4.5 5.5 6.5\n\n\nSo, using the colon, we can get a slice of a vector, using the following syntax:\nvector[start_index:stop_index]\nFor example,\n\nvec[2:4]\n\n[1] 10 15 20\n\n\nNotice how the elements both at the starting and stopping index are included.\n\n\n\nWe have previously seen that we can assign names to the elements of a vector. For example,\n\nvec &lt;- c(5, 10, 15, 20, 25)\nnames(vec) &lt;- c(\"a\", \"b\", \"c\", \"d\", \"e\")\nvec\n\n a  b  c  d  e \n 5 10 15 20 25 \n\n\nWe can then use the name along with the indexing brackets to grab the individual elements from the vector.\n\nvec[\"c\"]\n\n c \n15 \n\n\nAgain, we can also pass a vector of names to grab more than one vector at the same time.\n\nvec[c(\"a\", \"c\", \"e\")]\n\n a  c  e \n 5 15 25 \n\n\n\n\n\nAs we have mentioned before, talking about the comparison operators with vectors, we can use comparison operators to filter out elements from a vector. Sometimes this is referred to as boolean/logical masking, because we are creating a vector of logicals to filter out results you want.\nLet’s see an example of this. Take the vector\n\nvec &lt;- 1:10\nvec\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nWe can pass to the brackets a logical statement.\n\nvec[vec &gt; 6]\n\n[1]  7  8  9 10\n\n\nLet’s break this down to see how it works. First, let’s have a look at the vector\n\nvec &gt; 6\n\n [1] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\n\n\nAs we can see, it returns a logical vector with the same length as vec whose elements says whether it is true or false that the element in that position is greater than 6. When we pass a logical vector, such as this, to another vector through the brackets, R will return only the elements of the vector corresponding to a true value in the logical vector.\nTo make this more clear, we could even assign a name to this logical vector and pass the name to the vector, like so:\n\nfilter &lt;- vec &gt; 6\nfilter\n\n [1] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\n\nvec[filter]\n\n[1]  7  8  9 10"
  },
  {
    "objectID": "vectors.html#two-useful-functions-to-generate-vectors",
    "href": "vectors.html#two-useful-functions-to-generate-vectors",
    "title": "Vectors",
    "section": "",
    "text": "Besides the function c() we have already seen that the colon operator from:to generates a sequence starting at from and ending at to. Another function that does the same job is seq(from, to, by = ). The parameter by specifies the increment of the sequence and its default value is 1. So, for example,\n\nseq(5, 16, by = 2)\n\n[1]  5  7  9 11 13 15\n\n\nAnother function that creates a vector is rep(x, times) which repeats the vector x times times.\n\nrep(c(1, 2), times = 3)\n\n[1] 1 2 1 2 1 2\n\n\nThe function rep has an alternative parameter each which repeats ‘each’ element of x each times. For example,\n\nrep(c(1, 2), each = 3)\n\n[1] 1 1 1 2 2 2"
  },
  {
    "objectID": "vectors.html#first-step-in-data-simulation",
    "href": "vectors.html#first-step-in-data-simulation",
    "title": "Vectors",
    "section": "",
    "text": "Sometimes instead of generating data with a pattern, we would like to simulate data. R is perfect for this job, as it has a very good implementation of all the most common and important statistical distributions needed. However, before we can simulate data, it is vital to say a few words about random data generation and reproducibility.\n\n\nAccording to Wikipedia, random number generation is a process by which, often by means of a random number generator (RGN), a sequence of numbers or symbols that cannot be reasonably predicted better than by random chance is generated. True random number generators are generally hardware based (for example by rolling a die). Software typically use a pseudo-random number generator (PRNG) which is an algorithm that generates a sequence of numbers that only looks random but that is in fact pre-determined. On Wikipedia there is long list of PRNGs, but for our scope, suffices it to say that the numbers that can be generated by R are in actual facts not random, but they would pass a random test, which means that they would look random from a mathematical point of view. If you want to know more about how R generates random numbers, you may wish to type help(\"RNG\") on your console.\n\n\n\nThis may look like a disadvantage, but it is actually a very important aspect of simulation. By means of the fact that random numbers are not-random after all, this means that if we “set a seed” we can then reproduce the exact random sequence again. This means that different user can perform the same simulation, obtaining the same result, as long as they use the same PRNG and they set the same seed.\nIn R the command to set the PRNG seed is set.seed().\nThis function needs to be assigned a number, the seed, which starts the sequence.\n\n\n\nLet’s see an example. Imagine we wish to roll a die. This means that we have a set of six possible outcomes (coded as 1 to 6), and by rolling a fair die we select one of them and all of them have the same probability (1 out of 6) to be selected. This can be done easily by sampling the set 1 to 6, i.e.\n\nset.seed(123)\nsample(1:6, 1)\n\n[1] 3\n\n\nImagine now we want to roll our die 10 times. This can be simulated using a similar code: we need to sample 10 times the set 1 to 6, but this sample must be with replacement. Thus we need to add the parameter replace = TRUE to the code to ensure that R samples with replacement. Let’s also set the same seed.\n\nset.seed(123)\nsample(1:6, 10, replace = TRUE)\n\n [1] 3 6 3 2 2 6 3 5 4 6\n\n\nWe may notice that having set the same seed, the first number is exactly the same as before.\n\n\n\n\n\n\nCaution\n\n\n\nA note of caution here: it is a good practice to set the seed every time we use a random generator function. In fact, once the seed has been set, the random function will use the PRGN in a specific way and different versions of the same function might use the PRNG in different ways. So once we access the PRNG again, it is good to always maintain control by choosing the seed, to ensure reproducibility.\n\n\n\n\n\nSuppose now we want to simulate a measurement (e.g. the temperature of a town). In this case we can’t sample from a population, but we need to use a statistical distribution. The statistical distribution that models a measurement is called the normal distribution and it has two parameters: the mean and the standard deviation. The mean represents the typical value of this measurement, and the standard deviation represent an approximation of the error made in taking this measurement.\nSo let’s run a simulation of 10 measurements of an average temperature of 18 degrees with a variability of 3 degrees.\n\nset.seed(101)\nrnorm(10, mean = 18, sd = 3)\n\n [1] 17.02189 19.65739 15.97517 18.64308 18.93231 21.52190 19.85637 17.66180\n [9] 20.75108 17.33022\n\n\nThis is way too accurate: let’s just round this to integers.\n\nset.seed(101)\nround(rnorm(10, mean = 18, sd = 3))\n\n [1] 17 20 16 19 19 22 20 18 21 17\n\n\nAnother very common distribution is the so called uniform distribution which gives the same probability to all numbers between a minimum and a maximum chosen numbers (defaults are min = 0 and max = 1). Let’s simulate 100 values from a uniform distribution:\n\nset.seed(111)\nrunif(100)\n\n  [1] 0.5929812845 0.7264811215 0.3704220036 0.5149238301 0.3776632159\n  [6] 0.4183373258 0.0106578451 0.5322952422 0.4321606164 0.0936815199\n [11] 0.5557799137 0.5902284889 0.0671411434 0.0475478533 0.1562025158\n [16] 0.4464277634 0.1714436871 0.9665342933 0.3106664298 0.6144663957\n [21] 0.4310607871 0.2855270915 0.3421513471 0.3866276275 0.9675274789\n [26] 0.3220267275 0.6532294548 0.2833034997 0.7874279192 0.5959206352\n [31] 0.0585964625 0.5098998600 0.4657924296 0.4693590938 0.3597453721\n [36] 0.7134103531 0.1163154817 0.7839926207 0.6421407105 0.8051009134\n [41] 0.6411978584 0.3284916454 0.6356909545 0.9285191579 0.5752422044\n [46] 0.3666838536 0.4366072204 0.8559219379 0.6279955737 0.7937756432\n [51] 0.7251648332 0.5850447209 0.0327716474 0.3329946804 0.9967166614\n [56] 0.5482733699 0.5758329388 0.4563152066 0.0965785654 0.8055401752\n [61] 0.0009253006 0.4667440471 0.1732608730 0.2592225648 0.9192820815\n [66] 0.2319295844 0.0525656715 0.3043926249 0.0117258150 0.3007076983\n [71] 0.8775839461 0.6652787277 0.4537648347 0.0533223320 0.6309068091\n [76] 0.4421851884 0.2673464869 0.9837744189 0.0951241532 0.7859691235\n [81] 0.1198521818 0.8812154671 0.1310980669 0.4003378763 0.0866140136\n [86] 0.3747997992 0.6847860171 0.7347726757 0.7709477365 0.5799853499\n [91] 0.5110989846 0.8529837073 0.6298211562 0.5790059080 0.7402492894\n [96] 0.3871497631 0.9935344572 0.3980894811 0.9750010339 0.8244822009\n\n\nThe table below shows the most common distributions with their syntax and a brief explanation.\n\n\n\n\n\n\n\n\nName\nSynatx\nExample of usage\n\n\n\n\nNormal distribution\nrnorm(n, mean = 0, sd = 1)\nThe normal distribution models measurements with mean mean and error sd\n\n\nUniform distribution\nrunif(n, min = 0, max = 1)\nThe uniform distribution is generally used to generate a sequence of random numbers\n\n\nBinomial distribution\nrbinom(n, size, prob)\nThe binomial distribution models the number of successes in size trials with probability of success prob\n\n\nPoisson distribution\nrpois(n, lambda)\nThe Poisson distribution is also called the “count” distribution: it models the number of events occurring at a constant rate in a given time frame. lambda is the mean number of events occurring.\n\n\nExponential distribution\nrexp(n, rate = 1)\nThe exponential distribution models the time to wait until the next event occurs, such as a failure or a success. rate is the average rate at which the events occur.\n\n\nGeometric distribution\nrgeom(n, prob)\nThe geometric distribution models the instant of first success in a sequence of trials with probability of success prob"
  },
  {
    "objectID": "vectors.html#first-steps-in-data-simulation",
    "href": "vectors.html#first-steps-in-data-simulation",
    "title": "Vectors",
    "section": "",
    "text": "Sometimes instead of generating data with a pattern, we would like to simulate data. R is perfect for this job, as it has a very good implementation of all the most common and important statistical distributions needed. However, before we can simulate data, it is vital to say a few words about random data generation and reproducibility.\n\n\nAccording to Wikipedia, random number generation is a process by which, often by means of a random number generator (RGN), a sequence of numbers or symbols that cannot be reasonably predicted better than by random chance is generated. True random number generators are generally hardware based (for example by rolling a die). Software typically use a pseudo-random number generator (PRNG) which is an algorithm that generates a sequence of numbers that only looks random but that is in fact pre-determined. On Wikipedia there is long list of PRNGs, but for our scope, suffices it to say that the numbers that can be generated by R are in actual facts not random, but they would pass a random test, which means that they would look random from a mathematical point of view. If you want to know more about how R generates random numbers, you may wish to type help(\"RNG\") on your console.\n\n\n\nThis may look like a disadvantage, but it is actually a very important aspect of simulation. By means of the fact that random numbers are not-random after all, this means that if we “set a seed” we can then reproduce the exact random sequence again. This means that different user can perform the same simulation, obtaining the same result, as long as they use the same PRNG and they set the same seed.\nIn R the command to set the PRNG seed is set.seed().\nThis function needs to be assigned a number, the seed, which starts the sequence.\n\n\n\nLet’s see an example. Imagine we wish to roll a die. This means that we have a set of six possible outcomes (coded as 1 to 6), and by rolling a fair die we select one of them and all of them have the same probability (1 out of 6) to be selected. This can be done easily by sampling the set 1 to 6, i.e.\n\nset.seed(123)\nsample(1:6, 1)\n\n[1] 3\n\n\nImagine now we want to roll our die 10 times. This can be simulated using a similar code: we need to sample 10 times the set 1 to 6, but this sample must be with replacement. Thus we need to add the parameter replace = TRUE to the code to ensure that R samples with replacement. Let’s also set the same seed.\n\nset.seed(123)\nsample(1:6, 10, replace = TRUE)\n\n [1] 3 6 3 2 2 6 3 5 4 6\n\n\nWe may notice that having set the same seed, the first number is exactly the same as before.\n\n\n\n\n\n\nCaution\n\n\n\nA note of caution here: it is a good practice to set the seed every time we use a random generator function. In fact, once the seed has been set, the random function will use the PRGN in a specific way and different versions of the same function might use the PRNG in different ways. So once we access the PRNG again, it is good to always maintain control by choosing the seed, to ensure reproducibility.\n\n\n\n\n\nSuppose now we want to simulate a measurement (e.g. the temperature of a town). In this case we can’t sample from a population, but we need to use a statistical distribution. The statistical distribution that models a measurement is called the normal distribution and it has two parameters: the mean and the standard deviation. The mean represents the typical value of this measurement, and the standard deviation represent an approximation of the error made in taking this measurement.\nSo let’s run a simulation of 10 measurements of an average temperature of 18 degrees with a variability of 3 degrees.\n\nset.seed(101)\nrnorm(10, mean = 18, sd = 3)\n\n [1] 17.02189 19.65739 15.97517 18.64308 18.93231 21.52190 19.85637 17.66180\n [9] 20.75108 17.33022\n\n\nThis is way too accurate: let’s just round this to integers.\n\nset.seed(101)\nround(rnorm(10, mean = 18, sd = 3))\n\n [1] 17 20 16 19 19 22 20 18 21 17\n\n\nAnother very common distribution is the so called uniform distribution which gives the same probability to all numbers between a minimum and a maximum chosen numbers (defaults are min = 0 and max = 1). Let’s simulate 100 values from a uniform distribution:\n\nset.seed(111)\nrunif(100)\n\n  [1] 0.5929812845 0.7264811215 0.3704220036 0.5149238301 0.3776632159\n  [6] 0.4183373258 0.0106578451 0.5322952422 0.4321606164 0.0936815199\n [11] 0.5557799137 0.5902284889 0.0671411434 0.0475478533 0.1562025158\n [16] 0.4464277634 0.1714436871 0.9665342933 0.3106664298 0.6144663957\n [21] 0.4310607871 0.2855270915 0.3421513471 0.3866276275 0.9675274789\n [26] 0.3220267275 0.6532294548 0.2833034997 0.7874279192 0.5959206352\n [31] 0.0585964625 0.5098998600 0.4657924296 0.4693590938 0.3597453721\n [36] 0.7134103531 0.1163154817 0.7839926207 0.6421407105 0.8051009134\n [41] 0.6411978584 0.3284916454 0.6356909545 0.9285191579 0.5752422044\n [46] 0.3666838536 0.4366072204 0.8559219379 0.6279955737 0.7937756432\n [51] 0.7251648332 0.5850447209 0.0327716474 0.3329946804 0.9967166614\n [56] 0.5482733699 0.5758329388 0.4563152066 0.0965785654 0.8055401752\n [61] 0.0009253006 0.4667440471 0.1732608730 0.2592225648 0.9192820815\n [66] 0.2319295844 0.0525656715 0.3043926249 0.0117258150 0.3007076983\n [71] 0.8775839461 0.6652787277 0.4537648347 0.0533223320 0.6309068091\n [76] 0.4421851884 0.2673464869 0.9837744189 0.0951241532 0.7859691235\n [81] 0.1198521818 0.8812154671 0.1310980669 0.4003378763 0.0866140136\n [86] 0.3747997992 0.6847860171 0.7347726757 0.7709477365 0.5799853499\n [91] 0.5110989846 0.8529837073 0.6298211562 0.5790059080 0.7402492894\n [96] 0.3871497631 0.9935344572 0.3980894811 0.9750010339 0.8244822009\n\n\nThe table below shows the most common distributions with their syntax and a brief explanation.\n\n\n\n\n\n\n\n\nName\nSynatx\nExample of usage\n\n\n\n\nNormal distribution\nrnorm(n, mean = 0, sd = 1)\nThe normal distribution models measurements with mean mean and error sd\n\n\nUniform distribution\nrunif(n, min = 0, max = 1)\nThe uniform distribution is generally used to generate a sequence of random numbers\n\n\nBinomial distribution\nrbinom(n, size, prob)\nThe binomial distribution models the number of successes in size trials with probability of success prob\n\n\nPoisson distribution\nrpois(n, lambda)\nThe Poisson distribution is also called the “count” distribution: it models the number of events occurring at a constant rate in a given time frame. lambda is the mean number of events occurring.\n\n\nExponential distribution\nrexp(n, rate = 1)\nThe exponential distribution models the time to wait until the next event occurs, such as a failure or a success. rate is the average rate at which the events occur.\n\n\nGeometric distribution\nrgeom(n, prob)\nThe geometric distribution models the instant of first success in a sequence of trials with probability of success prob"
  }
]